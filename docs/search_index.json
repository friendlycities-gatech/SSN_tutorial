[
["index.html", "Spatial Social Networks (SSN) Visualization and Metrics with R Chapter 1 Introduction", " Spatial Social Networks (SSN) Visualization and Metrics with R Xiaofan Liang, Clio Andris, Dipto Sarkar 2021-11-18 Chapter 1 Introduction This tutorial is dedicated to describe the basic concepts, methods, and visualizations involved to map and analyze non-planar networks (social networks &amp; relationships) in geographic space using R. A non-planar network is a network in which the nodes are geolocated, while the edges can cross over each other without creating new nodes. For example, mapping Facebook friendships and flight routes in geographic space are non-planar. A planar network is spatially embedded in a way that the edges intersect only at the endpoints, such as the road, river, and eletrical grid networks. There are already some tutorials for mapping and analyzing planar networks, but none exists for non-planar networks. We assume our audience has basic knowledge of R programming with Tidyverse pakcage and basic GIS concepts (e.g., basic geometry types, coordinate system projection, spatial operation etc.). If not, you can use this book Geocomputation with R to get started with the basic concepts. The book also leverages tmap at map visualization. In fact, many of our codes in this tutorial are inspired by this book. Mapping relationship in geographic space has its own challenges, which is described thoroughly in Andris’s paper Challenges for Social Flows. In our visualization examples, we will try to show the best practices to map social networks in space that can counter some of these problems. All the data you need to complete the tutorial will be downloaded from Friendly Cities Lab GitHub page. Required Packages We use igraph package to calculate network metrics, sf package to create geospatial objects from dataframe, tmap package to create both static and interactive maps, tmaptools package to extract OpenStreetMap basemaps, and tidyverse package as the syntax to process data. You can download the packages using the following codes: install.packages(&quot;igraph&quot;) #for network analysis install.packages(&quot;sf&quot;) #for spatial objects operation install.packages(&quot;tmap&quot;) #for mapping install.packages(&quot;tmaptools&quot;) #for using read.osm to extract basemaps install.packages(&quot;stars&quot;) #for using Mapbox to extract basemaps install.packages(&quot;tidyverse&quot;) #for data processing install.packages(&#39;tigris&#39;) #for loading TIGRR shapefiles install.packages(&quot;devtools&quot;) #to download R package on GitHub devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) There are a few packages for visualizing maps. We chose tmap in the end for its flexibility to switch between interactive maps and static plots. ggpplot2 has powerful mapping functions. It is intuitive for people who are used to the underlying logic of ggplot2. One advantage of ggpplot2 is that it can easily add high-resolution Google Maps as basemaps using ggmap package (only in WGS84 projection). Here are some good tutorials that teach you how to use ggplot2 to map planar networks and produce basic elements of a map. However, you need to convert spatial objects to dataframe for ggpplot2 to draw on. cartography has limited mapping functions, but can come in handy when you only need to draw a few simple types of maps. It has some functions that are very friendly for mapping spatial networks, such as getLinkLayer that takes in point shapefiles and edge tables and return edge shapefiles. You can also overlay proportional symbols and proportional links layers. However, you may not get to control the details of the maps in the most desirable ways. tmap is equally powerful as ggpplot2, and has the extra function to switch between a static plot and interactive plot mode. This feature is useful when you want to zoom in and out to explore your data. The interaction component is operationalized through Leaflet package. To draw basemaps with tmap, you can either use the read_osm function in tmaptools or use package stars to wrap around the raster downloaded through Mapbox API. For read_osm to work, you will need to install rJava for the function to run, which may further require downloading Java and Java Development kit. You can see Chapter X for examples to add basemaps. sf converts data frame into spatial objects that can be used in base R plot function and tmap. It can also conduct various spatial operation, such as coordinate system projection, spatial joins, and topological relations. A brief introduction of how to streamline sf and tmap is given in the book Geocomputation with R. igraph is the go-to package for network analysis, such as calculating the centrality measures of a network. These measures may become the attributes for nodes or edges in the maps. We will show the workflow from igraph to tmap with examples in Chapter X. tidyverse provides a set of packages that share the same data representation and use the pip symbol %&gt;% to connect steps of processing. tigris download geographic boundary shapefiles from TIGER website. SSNtools is an R package that provides metrics for analyzing and visualizing spatial social networks. "],
["metrics.html", "Chapter 2 Network Metrics 2.1 Network Data Formats 2.2 Network Metrics 2.3 igraph Visualization", " Chapter 2 Network Metrics In this chapter, we introduce the following topics: Data formats of network data Network metrics for nodes and edges How to visualize an igraph network graph We only introduce basic concepts here for reference. If you want to learn more about visualizing abstractions of networks (which are not geographically embedded) and network metrics, Katherine Ognyanova has an awesome tutorial here. 2.1 Network Data Formats Nodes and edges are the two key components of a network. Nodes may also refer as vertices (vertex for singular). There are two common data formats to store data for nodes and edges. The first one is an adjacency matrix (see 2.1 as an example), and the second one is a node table and an edge list (see 2.2 and 2.3 as an example). In a node table, one row contains all the attributes (e.g., degree, coordinates, values) for one node. In an edge table, one row represents an edge pair and all the attributes associated with the edge (e.g., weight). The following examples show data formats for a network using remittance data between China, Mexico, and Canada. Table 2.1: Adjacency Matrix China Mexico Canada China 0 48520 4144020 Mexico 2520 0 155790 Canada 19650 8980 0 Table 2.2: Node table Node_id Country_name Population_estimate Longitude Latitude 1 China 1338612970 103.11 35.69 2 Mexico 111211789 -102.18 23.73 3 Canada 33487208 -96.09 57.89 Table 2.3: Edge list Edge_id Origin Destination Remittance 1 China China 0 2 China Mexico 2520 3 China Canada 19650 4 Mexico China 48520 5 Mexico Mexico 0 6 Mexico Canada 8980 7 Canada China 4144020 8 Canada Mexico 155790 9 Canada Canada 0 2.2 Network Metrics igraph package provides functions that calculate a few network metrics for nodes and edges in an network. It can construct a network from the two common data formats: using graph_from_data_frame with a node table and an edgelist (edgelist alone works too) or graph_from_incident_matrix with an adjacency matrix. g = graph_from_data_frame(YOUR_EDGELIST, directed=TRUE) g = graph_from_data_frame(YOUR_EDGELIST, vertices=YOUR_NODETABLE, directed=TRUE) g = graph_from_incident_matrix(YOUR_MATRIX, directed=TRUE) Here are some common network metrics that are used to measure properties of nodes, edges, and network structure as a whole: 2.2.1 Network Metrics for Nodes Degree: measures the total connections of a node, regardless of the direction of the connections. V(g)$degree = degree(g, v=V(g), mode=c(&#39;all&#39;)) #add degree to nodes in the network g In Degree measures the total connections that flow to a node. V(g)$degree = degree(g, v=V(g), mode=c(&#39;in&#39;)) #add in degree to nodes in the network g Out Degree measures the total connections that flow out from a node. V(g)$degree = degree(g, v=V(g), mode=c(&#39;out&#39;)) #add out degree to nodes in the network g Weighted Degree measures the sum of the edge weights to a node, which is correlated with the degree of a node but weighted. The weighted in degree and weighted out degree use the same code, but change the mode to “in” and “out”. #Edgelist should include weight column for the code to work. V(g)$weighted_degree = strength(g, v=V(g), mode=c(&#39;all&#39;)) #add weighted degree to nodes in the network g Closeness Centrality measures the closeness of one node to all other nodes in the network. A high value means that a node, on average, can reach all other nodes in a few steps. It is calculated as the reciprocal of the sum of the length of the shortest path between a node and all other nodes in the graph. V(g)$closeness_centrality = closeness(g, vids=V(g), mode=&#39;in&#39;) #add closeness centrality (mode = &#39;in&#39; uses in degree as paths to a node) to nodes in the network g Betweenness Centrality measures the importance of a node in calculating the shortests paths of all nodes in a network. A high value means that a node, if removed from the network, will make the shortest path calculation longer for many other nodes in the network. It is calculated as the number of shortest paths that pass through the node. V(g)$betweenness_centrality = betweenness(g, v=V(g), directed=TRUE) #add betweenness centrality to nodes in the network g Eigenvector Centrality (sometimes called PageRank Centrality) measures the influence a node has on a network. A node has high influence if it is connected to many nodes who themselves have high influences. V(g)$eigenvector_centrality = eigen_centrality(g, directed=TRUE)$vector #add eigenvector centrality to nodes in the network g (Local) Clustering Coefficient measures how close the neighbors of a node all connect to each other, and thus how embedded a node is in its local networks. It is also called the local clustering coefficient. V(g)$clustering_coefficient = transitivity(g, type=&#39;local&#39;) #add local clustering coefficient to nodes in the network g Eccentricity measures the shortest path distance to the farthest other node in the network. V(g)$eccentricity = eccentricity(g, vids=V(g), mode=c(&#39;all&#39;)) #add eccentricity to nodes (path calculated as undirected) in the network g Shortest Path is the shortest path from one node to another in the network. It contains a list of nodes that the path passes by. get.shortest.paths(g, 1, 3) #give you the shortest path from node 1 to node 3. The path will show the number or the name of the nodes passed. Igraph package labels every node with a number. Hops is the number of steps for one node to jump to another node. length(get.shortest.paths(g, 1, 3)$vpath[[1]]) #measure the number of hops from node 1 to node 3 2.2.2 Network Metrics for Edges Weight can represent the value of the connection, such as volumes of flows or the extent of strength (e.g., trust). E(g)$weight = YOUR_WEIGHT_VECTOR #assign weights to edges Edge Betweenness measures the number of shortest paths pass through an edge. E(g)$edge_betweenness = edge_betweenness(g, e=E(g), directed=TRUE) #calculate edge_betweenness for all edges in a network For network structures: Diameter measures the maximum distance between any pairs of nodes in a network. In another word, it is the maximum eccentricity of any node. d = diameter(g, directed=FALSE) #calculate diameter of a network (Global) Clustering Coefficient measures the degree to which nodes in a network tend to cluster together. Global clustering coefficient is calculated as the ratio of the number of closed triplets and the total number of triplets. global_clustering_coefficient = transitivity(g, type=&#39;average&#39;) #calculate global clustering coefficient of a network Average Path Length measures the mean of the lengths of the shortest paths between all pairs of nodes in the network. avg_path_length = average.path.length(g, directed=FALSE) #calculate the average path length of a undirected network 2.3 igraph Visualization Here is an example using data about the American Mafia to visualize an igraph network. This data was collected by Dan DellaPosta at Penn State and published in the paper Network closure and integration in the mid-20th century American mafia. The node table contains: Name of the Mafia member Mafia family the member belongs to Whether the member is in New York City Longitude and Latitude of the location of the member The edge list contains pairs of undirected connections: Source (the name of a member) Target (the name of a different member) The node size varies by the values of local clustering coefficient, and the node color varies by the mafia family the node belongs to. library(igraph) library(SSNtools) #MafiaNodes and MafiaEdges are built-in datasets in SSNtools package g &lt;- graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaNodes) #set the node size to base on clustering coefficients V(g)$size &lt;- transitivity(g, type=&#39;local&#39;) #Set the node color to vary by mafia family group. # ---- get all color from a color device color = grDevices::colors()[grep(&#39;gr(a|e)y&#39;, grDevices::colors(), invert = T)] # ---- sample n color, in which n = family groups colrs &lt;- sample(color, length(unique(V(g)$Family))) # ---- #assign color to correpsonding mafia family member V(g)$color &lt;- colrs[as.numeric(factor(V(g)$Family))] #Plot igraph network plot(g, vertex.label = NA, vertex.color = V(g)$color, vertex.size = 50*V(g)$size, #Scaled node size edge.width=0.5, layout=layout_with_fr(g) ) #Add node color legend fname = sort(unique(V(g)$Family)) #sort the legend labels legend(x=-2.2, y=1.5, #legend position legend=fname, pch=21, #solid circle with one color pt.bg=colrs[as.numeric(factor(fname))], pt.cex=1, cex=.7, bty=&quot;n&quot;, ncol=1, title = &#39;Node Color: Family Group&#39; ) #Add node size legend # ---- quantile breaks to show node size breaks = round(quantile(V(g)$size, c(0.2, 0.4, 0.6, 0.8, 1)),2) legend(x = -2.2, y = -1.2, #legend position legend=breaks, pch=21, pt.bg=NA, #no color background cex=0.7, #size of legend pt.cex=breaks * 10, #Scaled node size bty=&quot;n&quot;, #node shape ncol=5, #number of column for legend text.width = 0.27, #adjust width of each column title = &#39;Node Size: Local Clustering Coefficient&#39;) "],
["nodes.html", "Chapter 3 Visualizing Nodes 3.1 Convert Coordinates to Points 3.2 Visualize Nodes 3.3 Visualize Nodes by Node Color 3.4 Visualize Nodes by Node Size 3.5 Visualize Nodes by Size and Color", " Chapter 3 Visualizing Nodes In this chapter, we continue to use the American Mafia data introduced in Chapter 2. This chapter covers the following topics: How to convert node coordinates into point geometry How to visualize nodes with constant color and size How to visualize nodes with varying node size by attributes How to visualize nodes with varying color by attributes How to visualize nodes with varying node size and color with a combined legend You will be able to find a copy of all the codes at the bottom of the page. Before proceeding to the codes, please load the following packages: library(sf) library(tidyverse) library(tmap) library(igraph) library(RColorBrewer) library(tigris) #install.packages(&quot;devtools&quot;) #to download R package on GitHub #devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) library(SSNtools) 3.1 Convert Coordinates to Points The data for the nodes may come in two common format. One is the node table that we mentioned in Chapter 2 (REF), and the other is spatial object, in which nodes are already point geometry. The node table often stores the spatial information of the node as two columns: latitude and longitude. Spatial object contains spatial information of the node in the geometry column. It also includes projection coordinates system of the object. Unless you are working with ggplot2, most other visualization packages require nodes to be spatial objects for mapping. You can convert a node table with coordinates into a spatial object with st_as_sf function in sf package. Spatial information is stored in the LonX and LatY column in MafiaNodes node table. Therefore, when we convert it to sf spatial object, we need to set the coordinates crs to be WGS84 (4326). #MafiaNodes is a built-in dataset in SSNtools R package MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) head(MafiaSpatial, 3) ## Simple feature collection with 3 features and 4 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -117.291 ymin: 34.1493 xmax: -77.5774 ymax: 43.1356 ## CRS: EPSG:4326 ## NODE Family NY NiceLabel ## 1 VALENTI-COSTENZA Bonanno 1 Costenza Valenti ## 2 VALENTI-FRANK Bonanno 1 Frank Valenti ## 3 DIPOLLITO-JOSEPH Los_Angeles 0 Joseph Dipollito ## geometry ## 1 POINT (-77.6064 43.1349) ## 2 POINT (-77.5774 43.1356) ## 3 POINT (-117.291 34.1493) 3.2 Visualize Nodes First step, we download the U.S. state shapefile through tigris package as the background for visualization and transform the shapefile and the dataframe data to the appropriate crs (coordinate reference system). The coordinate information can be stored in other projection system other than the commonly used WGS84. Users need to find out what crs is used before transforming the data to another system. Only when crs are the same for two or more shapefiles (or geometry) can we overlay them correctly on each other. Since we are mapping the data on U.S. mainland, we exclude U.S. territories and further transform the node table into sf spatial objects with North America Equidistant Conic projection (crs=102010). #Convert coordinate system MafiaSpatial = MafiaSpatial %&gt;% st_transform(MafiaSpatioal, crs=102010) #states is a function in tigris to download U.S. state boundary shapefile us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) %&gt;% st_transform(crs=102010) Second step: visualize the nodes on the US state map! tmap_mode(&#39;plot&#39;) # set tmap plotting mode to static map tm_shape(us_states) + tm_polygons() + #draw U.S. state shapefile first as polygons tm_shape(MafiaSpatial) + tm_symbols() #overlay nodes as points 3.3 Visualize Nodes by Node Color The map above only shows the locations of Mafia members. We want to visualize the influence of these members and find out where influential people reside. We load the edge file MafiaEdges and calculate the degree of each node. To vary the node color by degree, we simply set the col argument to the variable degree that should vary by color. Different from node size, style argument can modulate the breaks for node color in different styles, such as quantile breaks, equal interval breaks, head/tail breaks and so on. The number of class is defaulted to five. To define the color, you can either pass a R palette (e.g., YlGnBu) or a vector of color to palette argument. More details can be found in tmap document. #MafiaEdges is a built-in dataset in SSNtools #Construct a network and calculate the degree for each node. g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( size=1, #constant node size col=&#39;degree&#39;, palette = &#39;YlGnBu&#39;, #define which numeric column to vary by color and the color palette style=&#39;quantile&#39;, n = 4, #define the color breaks using quantile, and set the number of classes to 4. alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, title.col=c(&#39;Degree of Connections&#39;)) 3.4 Visualize Nodes by Node Size To visualize the node size by the connection degree, we have to set the node size varies by degree in tm_symbols. The default breaks for node size is interval breaks. You can adjust the breaks for node size in the legend directly through sizes.legend argument in tm_symbols. # Visualize tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + #turn the background color of the polygons to transparent tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, #scale up the node size col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) If you want node size to follow a particular break, then nodes need to be grouped into size brackets. Differnt from color whose breaks can be adjusted in style argument (e.g., style=‘quantile’), changing node size is not straightforward. This example shows how to size nodes in quantile breaks. We first check the quantile breakdown of the degree in the data as the reference. Then, we create a new degree_brackets column that group nodes with different degree to ordered categories. Lastly, we set the size argument in tm_symbols to the new degree_brackets column, which changes the size of the nodes in the map. We adjust the legend breaks using sizes.legend. sizes.legend only changes the size of the nodes in the legend but not for nodes in the map (use scale for the latter). More details can be found in tmap document. The final node size in the map = relative node size defined in degree_brackets / size.max * scale Numbers in the degree_brackets column only define the relative size difference between the nodes. size.max and scale are often defaulted to be 1, therefore makes it easy for people to directly define node size in the degree_brackets column. In that case, the node with designated with the highest size value will have the node size of 1. In our example, node size of 1 is visually too small in the map, so we scale up the node size by 1.5. Thus, the actual node sizes for the four brackets are c(0.1, 0.3, 0.5, 1)/1*1.5 = c(0.15, 0.45, 0.75, 1.5). quantile(MafiaSpatial$degree) ## 0% 25% 50% 75% 100% ## 2 8 12 20 154 # Create a new &#39;degree_bracket&#39; column that contains the node size for each group of nodes. MafiaSpatial = MafiaSpatial %&gt;% mutate(degree_brackets = case_when( degree &gt;= 2 &amp; degree &lt; 8 ~ 0.1, degree &gt;= 8 &amp; degree &lt; 12 ~ 0.3, degree &gt;= 12 &amp; degree &lt; 20 ~ 0.5, degree &gt;= 20 &amp; degree &lt;= 154 ~ 1 )) # Visualize tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, sizes.legend = c(0.1, 0.3, 0.5, 1)/1*1.5, sizes.legend.labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, #blue grey alpha=0.5, border.alpha = 0.5, title.size=c(&#39;Degree of Connections&#39;)) 3.5 Visualize Nodes by Size and Color The automatic legend in tmap now cannot support color and size legend in one. To combine the color and size legend, we have to manually create a legend with the color and size attributes from the color and size legends, using tm_add_legend. To replicate the color, we use RColorBrewer package to generate colors for a given number, which is the default way that tmap assigns colors. To replicate the size, we pass in the square root of the actual node size. Setting node size in tm_add_legend is tricky, which is the square roots of the actual node size (see here for detail explanation). Remember: The final node size in the map = relative node size defined in degree_brackets / size.max * scale. Lastly, we set the legend.col.show =FALSE and legend.size.show =FALSE to hide the default legends. tmap_mode(&#39;plot&#39;) map = tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( #arguments that define point sizes size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, legend.size.show = FALSE, #arguments that define point colors col=&#39;degree_brackets&#39;, palette = &#39;YlGnBu&#39;, n = 4, alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, legend.col.show = FALSE) + tm_add_legend(type=c(&quot;symbol&quot;), col = brewer.pal(4, &quot;YlGnBu&quot;), #copy the color from R palette alpha = 0.5, is.portrait = FALSE, # legend becomes horizontal # size defined here should be the sqaure root of the normalized point size * scale. # The square root is taken since the area is proportional to the data, not the radius. size = (c(0.1,0.3,0.5,1)/1)^0.5*1.5, labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), #break labels border.col = &#39;black&#39;, border.alpha = 0.2, title = c(&quot;Degree of Connections&quot;)) map To export the tmap object into a local folder, you can add: tmap_save(map, filename=&#39;YOUR_LOCAL_FOLDER_PATH/map.png&#39;) The full codes for creating the map above is in the following: library(readr) library(igraph) library(tmap) library(sf) library(tidyverse) library(RColorBrewer) library(SSNtools) #read data MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) us_states = states(cb=TRUE, progress_bar=FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) %&gt;% st_transform(crs=102010) # Construct a network and calculate the degree for each node. g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) # Create a new column that assign point size to points with varying degree. MafiaSpatial = MafiaSpatial %&gt;% mutate(degree_brackets = case_when( degree &gt;= quantile(MafiaSpatial$degree)[1] &amp; degree &lt; quantile(MafiaSpatial$degree)[2] ~ 0.1, degree &gt;= quantile(MafiaSpatial$degree)[2] &amp; degree &lt; quantile(MafiaSpatial$degree)[3] ~ 0.3, degree &gt;= quantile(MafiaSpatial$degree)[3] &amp; degree &lt; quantile(MafiaSpatial$degree)[4] ~ 0.5, degree &gt;= quantile(MafiaSpatial$degree)[4] &amp; degree &lt;= quantile(MafiaSpatial$degree)[5] ~ 1 )) # Visualize tmap_mode(&#39;plot&#39;) map = tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( #arguments that define point sizes size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, legend.size.show = FALSE, #arguments that define point colors col=&#39;degree&#39;, palette = &#39;YlGnBu&#39;, style=&#39;quantile&#39;, n = 4, alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, legend.col.show = FALSE) + tm_add_legend(type=c(&quot;symbol&quot;), col = brewer.pal(4, &quot;YlGnBu&quot;), #copy the color from R palette alpha = 0.5, is.portrait = FALSE, # legend becomes horizontal # size defined here should be the sqaure root of the normalized point size * scale. # The square root is taken since the area is proportional to the data, not the radius. size = (c(0.1,0.3,0.5,1)/1)^0.5*1.5, labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), #break labels border.col = &#39;black&#39;, border.alpha = 0.2, title = c(&quot;Degree of Connections&quot;)) #tmap_save(map, filename=&#39;YOUR_LOCAL_FOLDER_PATH/map.png&#39;) "],
["vizedges.html", "Chapter 4 Visualizing Edges 4.1 Convert Points into Lines 4.2 Visualizing Edges 4.3 Visualizing Edges by Line Width 4.4 Visualizing Edges by Color 4.5 Visualizing Edges by Width and Color", " Chapter 4 Visualizing Edges In this chapter, we will use commute data from U.S. Census LEHD (Longitudinal Employer-Household Dynamics) Origin-Destination Employment Statistics (LODES). We will use lehdr package to download LODES commute data between counties in Georgia and use tigris to download county shapefiles and convert to centroids as points in the spatial networks. This chapter covers the following topics: How to convert point data into line geometry How to visualize edges with constant color and size How to visualize edges with varying edge width by attributes How to visualize edges with varying edge color by attributes How to visualize edges with varying edge size and edge color with a combined legend You will be able to find a copy of all the codes at the bottom of the page. Before proceeding to the codes, please load the following packages: library(sf) library(tidyverse) library(tmap) library(tigris) library(lehdr) 4.1 Convert Points into Lines To start, we use lehdr package to download LODES commute data between counties in Georgia and use tigris package to download county shapefiles and convert to centroids as points in the spatial networks. #counties is a function in tigris package GA_county = counties(state = &#39;GA&#39;, cb=TRUE, year=2018, progress_bar=FALSE) #grab_lodes is a function in lehdr package data = grab_lodes(state=&#39;ga&#39;, year=2018, lodes_type = &#39;od&#39;, state_part = &#39;main&#39;, agg_geo = &#39;county&#39;) #filter top 1000 county-to-county flows ctc_commutes = data %&gt;% select(c(w_county, h_county, S000)) %&gt;% rename(flow = S000) %&gt;% filter(h_county != w_county) %&gt;% arrange(desc(flow)) %&gt;% slice(1:1000) head(ctc_commutes, 3) ## # A tibble: 3 × 3 ## w_county h_county flow ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 13121 13089 128889 ## 2 13121 13067 109627 ## 3 13121 13135 87646 Columns h_county and w_county contain the county FIPS (or GEOID) codes. S000 contains the total number of job flows between the home county and the work county. We also only want to create lines between counties, so we will filter out flows that have the same h_county and w_county. There are two ways to convert points into a line geometry. 4.1.1 Method 1: Group by lineID and Summarize Points into Line The first one is to group the points coordinates by line ID, summarize the flow values, and then use st_cast in the sf package to turn the grouped point coordinates into a line geometry. This method is particularly useful if you start with a file that only contain coordinates but no geometry. It is also convenient GPS trajectory data because each row is a point data associated with a line ID and you want to connect all the points that represent one trajectory. For our data, we have a flow dataframe that contains the origin and destination ID and the flow volumn, and a separate county centroid shapefile that can be joined to the flow dataframe. To leverage method 1, we have to split one OD pair into two rows so that the first row contains the point geometry of the origin and the second row contains the point geometry of the destination. To do that, we perform a little trick: we swap the position of the h_county and w_county of ctc_commutes and bind it to the existing ctc_commutes dataframe. Then when we join county shapefiles by h_county, we actually join the shapefiles for both the origin county and the destination county. Then we can use the group_by and summarise method to create lines. Noted that column ID needs to be created before and during binding the ctc_commutes, so that group_by knows which OD is one the same line. You also need to ensure the dataframe is an sf object after doing left_join through st_as_sf(). edges = ctc_commutes %&gt;% mutate(ID = row_number()) %&gt;% bind_rows(ctc_commutes %&gt;% rename(w_county = h_county, h_county = w_county) %&gt;% mutate(ID = row_number())) %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% st_as_sf() %&gt;% group_by(ID) %&gt;% summarize(w_county=first(w_county), h_county = first(h_county), flow=mean(flow)) %&gt;% st_cast(&quot;LINESTRING&quot;) head(edges, 3) ## Simple feature collection with 3 features and 4 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -84.5767 ymin: 33.77149 xmax: -84.02363 ymax: 33.96167 ## CRS: 4269 ## # A tibble: 3 × 5 ## ID w_county h_county flow geometry ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;LINESTRING [°]&gt; ## 1 1 13121 13089 128889 (-84.4676 33.78992, -84.22637 33.77149) ## 2 2 13121 13067 109627 (-84.5767 33.94143, -84.4676 33.78992) ## 3 3 13121 13135 87646 (-84.4676 33.78992, -84.02363 33.96167) 4.1.2 Method 2: Join Two Point Geometry into One Row and Unite into Line The second way to convert points into lines is to join two point geometry in one row and cast them into a line. This method is particularly useful if you already have separate geometry files for origin and destination nodes, which is the case for our data. edges = ctc_commutes %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;w_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% mutate(geometry = st_cast(st_union(geometry.x, geometry.y), &quot;LINESTRING&quot;)) %&gt;% select(-c(geometry.x, geometry.y)) %&gt;% st_as_sf() head(edges, 3) ## Simple feature collection with 3 features and 3 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -84.5767 ymin: 33.77149 xmax: -84.02363 ymax: 33.96167 ## CRS: 4269 ## # A tibble: 3 × 4 ## w_county h_county flow geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;LINESTRING [°]&gt; ## 1 13121 13089 128889 (-84.4676 33.78992, -84.22637 33.77149) ## 2 13121 13067 109627 (-84.5767 33.94143, -84.4676 33.78992) ## 3 13121 13135 87646 (-84.4676 33.78992, -84.02363 33.96167) 4.2 Visualizing Edges The simplest edge visualization code snippet using tmap is the following: tmap_mode(&#39;plot&#39;) #Visualize edges tm_shape(GA_county) + tm_polygons() + tm_shape(edges) + tm_lines() 4.3 Visualizing Edges by Line Width To visualize edges by line width, we added a column variable flow for line width in tm_lines(). tmap_mode(&#39;plot&#39;) tm_shape(GA_county) + #change polygon background to be transparent tm_polygons(alpha=0, border.col = &#39;black&#39;) + tm_shape(edges) + #define line width and properties associated with lines tm_lines(lwd=&#39;flow&#39;, scale=10, alpha=0.5, legend.lwd.is.portrait = TRUE, title.lwd = c(&#39;Commutes Across Counties&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.07)) The default line width setting is proportional to the column variable (in this case, flow values). As you can see, this default is not a good visualization for the map because edges with small amount of flows are too thin to be seen. In reality, the degree weight distribution of non-planar networks is often skewed, with a few edges have very high flow values and most of the rest have low values. Therefore, we need to adjust the breaks to better visualize the spatial network. To adjust the line width breaks, we need to create a column to store relative edge width, which is similar to the node size visualization in chapter 2. We chose a skewed quantile breaks for line width. # We design the breaks for edge width through a skewed quantile distribution brks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0) # We create a column called flow_breaks that stores relative line width edges = edges %&gt;% mutate( flow_width = case_when( flow &gt;= brks[1] &amp; flow &lt;= brks[2] ~ 0.1, flow &gt; brks[2] &amp; flow &lt;= brks[3] ~ 0.3, flow &gt; brks[3] &amp; flow &lt;= brks[4] ~ 0.5, flow &gt; brks[4] &amp; flow &lt;= brks[5] ~ 1 ) ) tmap_mode(&#39;plot&#39;) tm_shape(GA_county) + tm_polygons(alpha=0, border.col = &#39;black&#39;) + # commute edges are arranged by flow values from high to low so that # high volumn flows will be plotted on the top of the low value ones. tm_shape(arrange(edges, flow)) + tm_lines(lwd=&quot;flow_width&quot;, scale=2, alpha=0.5, lwd.legend = c(0.1, 0.3, 0.5, 1)*2, legend.lwd.is.portrait = TRUE, lwd.legend.labels=c(&#39;300-600&#39;,&#39;601-3400&#39;, &#39;3401-30,000&#39;,&#39;30,001-130,000&#39;), title.lwd = c(&#39;Commutes Across Counties&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.05)) 4.4 Visualizing Edges by Color To visualize edges by color, we assign a variable column flow to argument col in tm_lines. Since we already established that the edges are better viewed through a skewed flow breaks, we manually assign break values for color. To do that, we give argument breaks a vector of fixed numbers, and set argument style to fixed. The following map has constant line width across different colors. tmap_mode(&#39;plot&#39;) tm_shape(GA_county) + tm_polygons(alpha=0, border.col = &#39;black&#39;) + tm_shape(arrange(edges, flow)) + # all the parameters for adjusting colors tm_lines(col=&quot;flow&quot;, alpha=0.5, scale = 1, breaks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, title.col = c(&#39;Commutes Across Counties&#39;), labels=c(&#39;300-600&#39;,&#39;601-3400&#39;,&#39;3401-30,000&#39;,&#39;30,001-130,000&#39;), palette=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.05)) 4.5 Visualizing Edges by Width and Color Similar to node visualization, to visualize edges with both line width and color, we need to add arguments for both and create a combined legend through tm_add_legend. Unfortunately, the package does not have an automatic way to combine color and line width legend together, so we have to define the values manually. tmap_mode(&#39;plot&#39;) map = tm_shape(GA_county) + tm_polygons(alpha=0, border.col = &#39;black&#39;) + tm_shape(arrange(edges, flow)) + tm_lines( #arguments that define the styles for color col=&quot;flow&quot;, alpha=0.8, breaks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, palette=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;), legend.col.show = FALSE, #arguments that define the styles for line width lwd=&quot;flow_width&quot;, scale=2, legend.lwd.show = FALSE) + #add manual legends to combine color and line width schema tm_add_legend( type=c(&#39;line&#39;), col=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;), lwd=c(1, 0.5, 0.3, 0.1), labels=c(&#39;300-600&#39;,&#39;601-3400&#39;,&#39;3401-30,000&#39;,&#39;30,001-130,000&#39;), title=&#39;Commutes Across Counties&#39;) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.05)) map Perfect! Now we can see clearly that commutes across counties are most intensive around the Atlanta metropolitan area and less so in the south of the state. We can further perfect the map by adding information about within county flows and visualize the numbers as node sizes. Here we show a new technique, which is to save the map we already plotted as a variable, and add new components to it. In this way, we do not have to regenerate the portion of the map that we already produced and speed up the mapping and testing time dramatically! # creating nodes as point geometry that represent within county flows nodes = data %&gt;% select(c(w_county, h_county, S000)) %&gt;% rename(flow = S000) %&gt;% filter(h_county == w_county) %&gt;% left_join(GA_county %&gt;% st_centroid(), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% st_as_sf() # here we use quantile breaks for node size brks = quantile(nodes$flow, probs=seq(0, 1, 0.25)) nodes = nodes %&gt;% mutate( size = case_when( flow &gt;= brks[1] &amp; flow &lt;= brks[2] ~ 0.1, flow &gt; brks[2] &amp; flow &lt;= brks[3] ~ 0.3, flow &gt; brks[3] &amp; flow &lt;= brks[4] ~ 0.5, flow &gt; brks[4] &amp; flow &lt;= brks[5] ~ 1 ) ) #visualize nodes on top of the map from last section map = map + tm_shape(nodes) + tm_symbols( size=&quot;size&quot;, scale=0.8, alpha=0, border.col=&#39;black&#39;, border.alpha=0.5, # values in sizes.legend = relative size defined in &#39;size&#39; column * scale sizes.legend = c(0.1, 0.3, 0.5, 1)*0.8, # labels have rounded the break values sizes.legend.labels=c(&#39;70-1000&#39;,&#39;1001-2500&#39;,&#39;2501-7000&#39;,&#39;7001-250,000&#39;), title.size=c(&#39;Commutes Within Counties&#39;), legend.size.is.portrait = TRUE) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.25)) #added margins to accomodate legends map To export the tmap object into a local folder, you can add: tmap_save(map, filename=&#39;YOUR_LOCAL_FOLDER_PATH/map.png&#39;) Here is the full code to replicate the map above library(sf) library(tidyverse) library(tmap) library(tigris) library(lehdr) #counties is a function in tigris package GA_county = counties(state = &#39;GA&#39;, cb=TRUE, year=2018, progress_bar=FALSE) #grab_lodes is a function in lehdr package data = grab_lodes(state=&#39;ga&#39;, year=2018, lodes_type = &#39;od&#39;, state_part = &#39;main&#39;, agg_geo = &#39;county&#39;) #filter top 1000 county-to-county flows ctc_commutes = data %&gt;% select(c(w_county, h_county, S000)) %&gt;% rename(flow = S000) %&gt;% filter(h_county != w_county) %&gt;% arrange(desc(flow)) %&gt;% slice(1:1000) #--- Create lines from OD dataframe ---# edges = ctc_commutes %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;w_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% mutate(geometry = st_cast(st_union(geometry.x, geometry.y), &quot;LINESTRING&quot;)) %&gt;% select(-c(geometry.x, geometry.y)) %&gt;% st_as_sf() # --- Convert flows within county into point geometry --- # nodes = data %&gt;% select(c(w_county, h_county, S000)) %&gt;% rename(flow = S000) %&gt;% filter(h_county == w_county) %&gt;% left_join(GA_county %&gt;% st_centroid(), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% st_as_sf() # --- Create Breaks for edge width --- # brks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0) edges = edges %&gt;% mutate( flow_width = case_when( flow &gt;= brks[1] &amp; flow &lt;= brks[2] ~ 0.1, flow &gt; brks[2] &amp; flow &lt;= brks[3] ~ 0.3, flow &gt; brks[3] &amp; flow &lt;= brks[4] ~ 0.5, flow &gt; brks[4] &amp; flow &lt;= brks[5] ~ 1 ) ) # --- Create Breaks for node size --- # brks2 = quantile(nodes$flow, probs=seq(0, 1, 0.25)) nodes = nodes %&gt;% mutate( size = case_when( flow &gt;= brks2[1] &amp; flow &lt;= brks2[2] ~ 0.1, flow &gt; brks2[2] &amp; flow &lt;= brks2[3] ~ 0.3, flow &gt; brks2[3] &amp; flow &lt;= brks2[4] ~ 0.5, flow &gt; brks2[4] &amp; flow &lt;= brks2[5] ~ 1 ) ) # --- Visualize the map ---- # tmap_mode(&#39;plot&#39;) map = tm_shape(GA_county) + tm_polygons(alpha=0, border.col = &#39;black&#39;) + tm_shape(arrange(edges, flow)) + tm_lines( #arguments that define the styles for color col=&quot;flow&quot;, alpha=0.8, breaks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, palette=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;), legend.col.show = FALSE, #arguments that define the styles for line width lwd=&quot;flow_width&quot;, scale=2, legend.lwd.show = FALSE) + #add manual legends to combine color and line width schema tm_add_legend( type=c(&#39;line&#39;), col=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;), lwd=c(1, 0.5, 0.3, 0.1), labels=c(&#39;300-600&#39;,&#39;601-3400&#39;,&#39;3401-30,000&#39;,&#39;30,001-130,000&#39;), title=&#39;Commutes Across Counties&#39;) + #add inner margin to accomodate legend size tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.1)) + # visualize nodes tm_shape(nodes) + tm_symbols( size=&quot;size&quot;, scale=0.8, alpha=0, border.col=&#39;black&#39;, border.alpha=0.5, # values in sizes.legend = relative size defined in &#39;size&#39; column * scale sizes.legend = c(0.1, 0.3, 0.5, 1)*0.8, # labels have rounded the break values sizes.legend.labels=c(&#39;70-1000&#39;,&#39;1001-2500&#39;,&#39;2501-7000&#39;,&#39;7001-250,000&#39;), title.size=c(&#39;Commutes Within Counties&#39;), legend.size.is.portrait = TRUE) + # since the default layout is too small to accomodate both legends tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.25)) map tmap_save(map, filename=&#39;YOUR_LOCAL_FOLDER_PATH/map.png&#39;) "],
["advanced-aesthetics.html", "Chapter 5 Advanced Aesthetics 5.1 Export for Editing 5.2 Small Multiples 5.3 Interactive Maps 5.4 Base Map 5.5 Inset Map 5.6 Edge Bundling", " Chapter 5 Advanced Aesthetics .Code { background-color: grey; } You may need one or more of these libraries to complete the codes in this chapter. library(sf) #required for any functions start with`st_` library(tidyverse) #required for any process that involves `%&gt;%` library(tmap) #required for any map visualization library(SSNtools) #required for any steps that involved MafiaNodes or MafiaEdges dataset library(igraph) #required for creating network from graph_from_data_frame and calculating network metrics library(OpenStreetMap) #required for loading base map library(stars) #required for loading base map library(tigris) #required for downloading boundary shapefiles library(grid) #required for inset library(edgebundle) #required for edge bundling 5.1 Export for Editing tmap allows users to export tmap object as a static map in the format of pdf, eps, svg, wmf, png, jpg, bmp, or tiff. You can define the resolution, height, and width of the export in the tmap_save arguments. tmap_save(tm = TMAP_OBJECT, filename=&#39;PATH/FILENAME.png&#39;) With these formats, you can import the tmap maps into Adobe Illustrators or Photoshop to further edit the details. You can also export the shapefiles you created in R to experiment in GIS softwares through sf package. #MafiaNodes is a built-in dataset from SSNtools MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) st_write(MafiaSpatial, &quot;MafiaSpatial.shp&quot;) Unfortunately, there isn’t a way to export tmap object to GIS softwares without losing the aesthetics yet (e.g., scale, size, color etc., see updates on this issue here). 5.2 Small Multiples In our case of the Mafia connectivity map, the power of the Mafia members can be represented by different network metrics. For example, degree centrality (i.e. degree connections) measures power as the number of connections to a Mafia member. Eigenvector centrality (i.e., PageRank centrality) measures power by not only the count of connections, but also the quality of connections so that connecting to other powerful members increases the weight of the link. Betweeness centrality measures power by the ability of a Mafia member to be the “middle-man/middle-woman” and connect groups of other members that would not be connected otherwise. (Local) Clustering coefficient measures whether a Mafia member’s friends tend to connect with each others (i.e., whether your friends are also your friends’ friends). Noted that closeness centrality is also a common measure of power, but the metric is not well-defined for disconnected graphs. In our dataset, there exists small Mafia cliques that do not interact with others. Thus, we did not use this metric. To contrast these different notions of power in the Mafia map, small multiple comes in handy. Small multiple is a group of charts or graphs that use the same scale or axes for easy comparison. Here we show how to create a small multiple of the Mafia member map with various network metrics through tmap tm_facets. Before we map the small multiple, there are some pre-processing. Firstly, when we add network metrics into the MafiaSpatial, each metric is in one column. However, the tm_facet only create multiples based on a column of value. Thus, we need to convert MafiaSpatial into a long table using gather function in tidyverse package (more accuratly, the tidyr package in tidyverse) so that column metric stores the type of metrics (e.g., “degree”, “eigen”, “betweenness”, “cluster”), and the column value stores the metric value. Secondly, we convert the metric column into a factor column, so that the order of the variable to be mapped is specified. Otherwise, the order of mapping for the small multiple will follow the alphebatical order of the value string in the metric column. Lastly, we also retrieve the state boundary shapefile from tigris as the background for the map. library(sf) library(tidyverse) library(tmap) library(SSNtools) library(igraph) library(tigris) #MafiaNodes and MafiaEdges are built-in dataset from SSNtools MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) #Calculate network metrics MafiaSpatial$degree = degree(g) MafiaSpatial$eigen = eigen_centrality(g)$vector MafiaSpatial$betweenness = betweenness(g, v=V(g)) MafiaSpatial$cluster = transitivity(g, type=&#39;local&#39;) MafiaSpatial = MafiaSpatial %&gt;% gather(key=&#39;metric&#39;, value=&#39;value&#39;, degree:cluster) %&gt;% mutate(metric = factor(metric, levels=c(&#39;degree&#39;, &#39;eigen&#39;, &#39;betweenness&#39;, &#39;cluster&#39;))) #states is a function from tigris package us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) Now we can map the small multiple! We specify the column metric in the by argument in tm_facets, which stores variables that the split will use. free.scales=T enables each facet (subplot) creates its own legend with its own scale. free.coords = F enables each map to have its own coordinate range, which is necessary if you have a multi-layer small multiple. You can specify the style of each facet in tm_layout with panel related arguments. In our example, we specify the name for each facet. tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_facets(by=&#39;metric&#39;, free.coords=F, free.scales = T) + tm_symbols(size=&quot;value&quot;, scale=1, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Measure of Power&#39;)) + tm_layout(panel.labels = c(&#39;Degree Centrality&#39;, &#39;Eigenvector Centrality&#39;, &#39;Betweenness Centrality&#39;, &#39;Clustering Coefficient&#39;)) From the maps above we can see that the most powerful mafia members are located around the New York City region. They are relatively more “powerful” in eigenvector centrality and betweenness centrality measures, and less so in degree centrality and clustering coefficients. Despite the concentration of power is in the Northeast, local mafia members can still be powerful as being well-embedded in a local social network. Many of the mafia families in the isolated regions (e.g., Colorado, Midwest, Texas) are very closely connected with each other. If you found the different value range across the metrics confusing or misleading (some metrics tend to follow power law), you can also standardize the metric values into respective percentile by adding the following lines before the gather. For example, a metric with value c(4, 1, 2, 3, 5) will be converted to c(0.75, 0, 0.25, 0.5, 1). MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) #Convert the metrics to percentile MafiaSpatial$degree = rank(degree(g))/length(degree(g)) MafiaSpatial$eigen = rank(eigen_centrality(g)$vector)/length(eigen_centrality(g)$vector) MafiaSpatial$betweenness = rank(betweenness(g, v=V(g)))/length(betweenness(g, v=V(g))) MafiaSpatial$cluster = rank(transitivity(g, type=&#39;local&#39;))/length(transitivity(g, type=&#39;local&#39;)) #same as above MafiaSpatial = MafiaSpatial %&gt;% gather(key=&#39;metric&#39;, value=&#39;value&#39;, degree:cluster) %&gt;% mutate(metric = factor(metric, levels=c(&#39;degree&#39;, &#39;eigen&#39;, &#39;betweenness&#39;, &#39;cluster&#39;))) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_facets(by=&#39;metric&#39;, free.coords=F, free.scales = T) + tm_symbols(size=&quot;value&quot;, scale=1, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Measure of Power&#39;)) + tm_layout(panel.labels = c(&#39;Degree Centrality&#39;, &#39;Eigenvector Centrality&#39;, &#39;Betweenness Centrality&#39;, &#39;Clustering Coefficient&#39;)) 5.3 Interactive Maps tmap allows users to view their maps in interactive modes with pre-defined Leaflet basemap styles, such as OpenStreetMap, Esri.WorldGrayCanvas, and Esri.WorldTopoMap. This is a quick and easy way to generate preliminary maps with base maps for presentations and illustrations. The interactive mode can also help you examine your data in a spatial context by adding pop up labels or hover labels. You can also publish your tmap interactive map to web through RPub under your account. As an example, copy and paste the following code in a Rmd file. You can create Rmd file from Rstudio File-&gt;New File-&gt;R Markdown. In R Markdown, Knit the file and the option to Publish should appear. You can select the RPub option and create a free account. See this post for more details. At the moment, the interactive map from tmap did not have the function to adapt the node size with the zoom level. This function exists in Leaflet package with addCircleMarkers() function (more details see this tutorial) #### ---- Uncomment the commented lines below in R markdown ----- #### #--- #output: html_document #--- #```{r warning=FALSE, message=FALSE, echo=TRUE, eval=FALSE} library(tidyverse) library(sf) library(tmap) library(SSNtools) library(igraph) MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) #set tmap_mode to &#39;view&#39; will enable interactive mode in Rstudio Plots window tmap_mode(&#39;view&#39;) tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=5, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;), #determine the hover label id = &#39;NiceLabel&#39;, #determine the pop up contents popup.vars = c(&#39;Name: &#39;=&#39;NiceLabel&#39;, &#39;Mafia Family: &#39;=&#39;Family&#39;, &#39;Degree of Connections: &#39;=&#39;degree&#39;)) + #add a function where you can see coordinates on mouseover tm_mouse_coordinates() #``` This is an example publish to RPub and what the output will look like. Click and hover your mouse in the map to explore the pop up labels and see the changing coordinates on the top left corner. You can also switch the base map style in the box below the zoom functions. You may notice in the tmap interactive map above that when you zoom in, the node size did not change, which makes it difficult to exam areas with clustered nodes (e.g., New York City). For more advanced interactive map functions, we suggest users swtich to Leaflet, which is an open-source library for web-based interactive maps. The following codes generate an interactive map in R and allows users to see the name of the Mafia members when hover over the nodes. The node size dynamically adjusts when you zoom and out of the map. For ideas to reduce node cluttering in the static map, refer to Inset Map. library(leaflet) leaflet(MafiaSpatial) %&gt;% addTiles() %&gt;% addCircleMarkers(radius = ~ sqrt(degree), fillColor=&#39;#6698CC&#39;, fillOpacity = 0.8, label=~htmlEscape(NiceLabel)) 5.4 Base Map While interactive map comes with base maps, you can manually add base map into static maps in tmap. This section shows you how to add Mapbox base map to tmap map in the plot mode. To use Mapbox base map, you need to create a token on Mapbox. Follow the instructions on Mapbox Docs to create your access token. You should keep this token private. We use st_bbox to find the bounding box of U.S. states and use the get_Mapbox function to retrieve Mapbox base map based on the input bounding box information. This base map raster can be visualized by tmap through tm_rgb(). library(tigris) library(OpenStreetMap) library(stars) library(sf) library(tidyverse) #bb: bounding box in st_bbox format. #token: your Mapbox token #style: Mapbox base map style. You can also insert customized style from Mapbox. token = &#39;YOUR MAPBOX TOKEN&#39; get_Mapbox = function(bb, token, style) { apiKey &lt;- paste0(&quot;?access_token=&quot;, token) baseUrl &lt;- paste0(&quot;https://api.mapbox.com/styles/v1/mapbox/&quot;, style, &quot;/tiles/256/{z}/{x}/{y}&quot;) #coordinate for upper left ul &lt;- c(attributes(bb)$bbox$ymax,attributes(bb)$bbox$xmin) #coordinate for lower right lr &lt;- c(attributes(bb)$bbox$ymin,attributes(bb)$bbox$xmax) map &lt;- openmap(ul,lr, minNumTiles=10, type=paste0(baseUrl,apiKey)) #process map into stars to be mapped in tmap map = st_as_stars(map) return(map) } #states is a function in tigris to download U.S. state boundary shapefile us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) box = st_bbox(us_states, crs=4326) bg = get_Mapbox(box %&gt;% st_as_sfc(), token, &#39;light-v10&#39;) tmap_mode(&#39;plot&#39;) map = tm_shape(bg) + tm_rgb() + tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=5, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;)) map You can find all the available Mapbox style here. You can also customize your Mapbox basemap in Mapbox Studio. To use the customized base map, replace the baseUrl in the function with your customized style URL (only replace path after https://api.mapbox.com/styles/), which you can find if you click “share” button for your customized style. This shows the output of the code above with Mapbox style: light-v10 (top left), dark-v10 (top right), outdoors-v11 (bottom left), satellite-v9 (bottom right). Sometimes you may want a customized bounding box that is not based on data layer. A helpful tool to find the coordinates around your data is to visualize your data in the interactive mode with tm_mouse_coordinates() (see example above). You can also specify the bounding box of your base map using the following code: #remember to add crs argument for specialized coordinates box = st_bbox(c(xmin=-77.25586, xmax=41.82353, ymin=-71.10352, ymax=38.94553), crs=4326) %&gt;% st_as_sfc() 5.5 Inset Map From the current mafia member map we can see that a lot of the mafia members cluster around the New York City region. We are not able to see the details in that areas due to cluttered nodes. This is a common problem at mapping spatial social networks when you have a both regional and local social connections. To decide on the Inset Map bounding box, you can either use the measurement from other shapefiles (e.g., NYC five boroughs) or use tm_mouse_coordinates() (see example in Interactive Map) to identify ideal bounding box. The example below uses information picked up by the tm_mouse_coordinates(). First, we need to create the inset map. We pick a bounding box around the central New York City including where the most connected mafia member (in degree of connections) locates. We also calculate aspect_ratio for the inset map so that when plugged into the background map, we can preserve the inset map’s natural ratio of height and width. #Create the bounding box for the inset map and retrieve corresponding base map bgbox = st_bbox(c(xmin=-74.065141, xmax=-73.537727, ymin=40.558198, ymax=40.882353), crs=4326) inset_bg = get_Mapbox(bgbox %&gt;% st_as_sfc(), token, &#39;light-v10&#39;) #Calculate aspect ratio. aspect_ratio = unname((bgbox$ymax - bgbox$ymin)/(bgbox$xmax - bgbox$xmin)) #putting base map as the first layer restricts the bounding box of the map, so no additional filtering for MafiaSpatial is needed. tmap_mode(&#39;plot&#39;) inset = tm_shape(inset_bg) + tm_rgb() + tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;), legend.size.show = FALSE) + tm_layout(main.title=&#39;Inset of New York&#39;, main.title.fontface = 2, main.title.position = c(&#39;center&#39;, &#39;top&#39;)) Then, we use tmap_save to export the background map map created in the Base Map section with the inset map. viewport function comes from the grid package and can be used to position the inset map on the background map. We set an arbitrary value for width and adjust the height according to the aspect ratio of the inset map to preserve its shape. You also can create multiple inset maps and pass to the insets_tm argument as a list (e.g., insets_tm = list(inset1, inset2)). Same for insets_vp. You can pass a list of viewport (e.g., insets_vp = list(viewport(X), viewport(Y))). #library(grid) tmap_save(map, insets_tm=inset, insets_vp = viewport(0.17, 0.75, width = 1, height = aspect_ratio*0.75), filename=&#39;PATH&#39;, dpi=600) We can also add a small black bounding box on the background map to indicate where the inset map locates. We also increase the line width of the frame of the inset map to visually match with the aesthetic of the bounding box. inset = inset + tm_layout(frame=TRUE, frame.lwd = 2) map = map + tm_shape(st_bbox(inset_bg) %&gt;% st_as_sfc()) + tm_polygons(alpha=0, border.col = &#39;black&#39;, lwd=2) tmap_save(map, insets_tm=inset, insets_vp = viewport(0.17, 0.75, width = 1, height = aspect_ratio*0.75), filename=&#39;PATH&#39;, dpi=600) 5.6 Edge Bundling Edge bundling is a technique to reduce visual cluttering of the edges. The algorithm behind edge bundling essentially bundles edges that go in the same direction and split them apart when they are close to their destinations. The algorithm of a complete edge bundling technique has three steps: first, it clusters edges based on their origin and destination; second, it calculates how to bend the geometry of a straight line given the user input of how “strong” you want the bundle to be. A stronger bundle means that you want more edges and edges far from the bundle to be bundled together; third, the algorithm may summarise the weights of the bundled edges so that the weight of the resultant bundle is larger (and thus visually thicker). You can implement edge bundling in QGIS2 or D3 or Python. This technique may help reveal structures in your edges when there are many lines, especially if you believe your edges follow a hierarchical structure, yet it is not a savior to your flow map. You should use this technique with caution because it has the following drawbacks: It takes a long time to do edge bundling. We recommend running our codes on a network with 1000-3000 edges to get quick feedback on the visual output. It may bend the edges in unnatural ways. It may be difficult to tell exactly where the edge come from and go to after you bend the edges. It may be difficult to visualize directionality in the flow map. You have to manually tune the parameters (thres in our case) to find the best visual outcome. There is no shortcut to find the optimized parameters at once. Some edge bundling package may only be able to bend the lines, but not summarise the edge weights. It means that it is difficult to visualize the edge weight of the bundle. The edgebundle package we used is still in development. We showed an example of applying the edgebundle package on the mafia map. To reduce the processing time, we filtered mafia connections to those that have more than 50km in euclidean distance, which results in 1668 edges. To filter by distance, we have to convert the coordinate system to North America Equidistant Conic (crs=102010), use st_distance to compute the distance between two point geometry, and lastly convert the meter object from st_distance into numeric numbers for filtering. It is important to note that you set by_element=TRUE in st_distance so that the output of the function is a vector rather than a matrix. The unit of the distance also follows the coordinate projection system you use. This is a mafia connectivity map without the edge bundling. #MafiaEdges and MafiaNodes is a built-in dataset of SSNtools package MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) #Filter MafiaEdges to edges that have more than 50km. FilteredEdges = MafiaEdges %&gt;% left_join(MafiaSpatial %&gt;% select(c(NODE, geometry)) %&gt;% st_transform(crs=102010), by = c(&#39;Source&#39; = &#39;NODE&#39;)) %&gt;% left_join(MafiaSpatial %&gt;% select(c(NODE, geometry)) %&gt;% st_transform(crs=102010), by = c(&#39;Target&#39; = &#39;NODE&#39;)) %&gt;% mutate(distance = st_distance(geometry.x, geometry.y, by_element=TRUE)) %&gt;% select(-c(geometry.x, geometry.y)) %&gt;% mutate(distance = as.numeric(distance)) %&gt;% filter(distance &gt; 50000) g = graph_from_data_frame(MafiaEdges, directed = FALSE) MafiaSpatial$degree = degree(g) #Convert FilteredEdges dataframe to line geometry. EdgeSpatial = FilteredEdges %&gt;% left_join(MafiaSpatial %&gt;% select(c(NODE, geometry)), by = c(&#39;Source&#39; = &#39;NODE&#39;)) %&gt;% left_join(MafiaSpatial %&gt;% select(c(NODE, geometry)), by = c(&#39;Target&#39; = &#39;NODE&#39;)) %&gt;% mutate(geometry = st_cast(st_union(geometry.x, geometry.y), &quot;LINESTRING&quot;)) %&gt;% select(-c(geometry.x, geometry.y)) %&gt;% st_as_sf() tmap_mode(&#39;plot&#39;) map = tm_shape(bg) + tm_rgb() + tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(EdgeSpatial) + tm_lines(lwd=0.5, alpha=0.3, col=&#39;#1B665D&#39;) + tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;)) map The map shows clearly that many of the connections are going to New York City. There are also a lot of connections that go stragith from west coast to east coast. Let’s try edge bundling and see if it makes the map better. The edge_bundle_force function from the edgebundle pacakage takes into three arguments: 1) g which is the network constructed through igraph, 2) xy which is the longitude and latitude of all the nodes in the network, and 3) compatibility_threshold which indicates the strength of the bundling. A higher value means that the bending and the bundling will be less intense. This package can only bend the edges into bundles but not beyond that. The result of the edge_bundle_force returns four columns. x and y are the coordinates of the points that consist of a bundled edge. group indicates that coordinates in the same group are for one bundled edge and index indicates the order of points for that particular bundled edge. We can see that for group 1, the fbundle result starts with the first name in the Source of FilteredEdges, BLANDA-CHARLES (-104.6270, 38.2476), and after 34 points, it will end with the Target, SMALDONE-EUGENE (-104.9479, 39.7681). library(edgebundle) #FilteredEdges %&gt;% slice(1:3) # Source Target distance # 1 BLANDA-CHARLES SMALDONE-EUGENE 97252.56 # 2 DIVARCO-JOSEPH SICA-JOSEPH 6054967.18 # 3 DEMARTINO-BENJAMIN DEMARTINO-THEODORE 182989.39 #The current EdgeSpatial is line geometry bundle_g = graph_from_data_frame(FilteredEdges, directed=FALSE) node = data.frame(id = V(bundle_g)$name) %&gt;% mutate(id = as.character(id)) #&gt; id #&gt; 1 BLANDA-CHARLES #&gt; 2 DIVARCO-JOSEPH #&gt; 3 DEMARTINO-BENJAMIN node = node %&gt;% left_join(MafiaNodes %&gt;% select(c(NODE, LonX, LatY)), by=c(&#39;id&#39; = &#39;NODE&#39;), copy=FALSE) #&gt; id LonX LatY #&gt; 1 BLANDA-CHARLES -104.6270 38.2476 #&gt; 2 DIVARCO-JOSEPH -87.7354 42.0154 #&gt; 3 DEMARTINO-BENJAMIN -72.9263 40.9530 xy = cbind(node$LonX, node$LatY) fbundle = edge_bundle_force(bundle_g,xy,compatibility_threshold = 0.85) #&gt; x y index group #&gt; 1 -104.6270 38.24760 0.00000000 1 #&gt; 2 -104.6506 38.30726 0.03030303 1 #&gt; 3 -104.6641 38.33735 0.06060606 1 Thus, to create lines acceptable to tmap from the fbundle result, we need to convert coordinates to points, group by the group column, and summarise the points into lines. It is important that do_union=FALSE argument is set in the summarise() to preserve the order of points (otherwise summarise will rearrange the point order). fbundle2 = fbundle %&gt;% st_as_sf(coords=c(&#39;x&#39;, &#39;y&#39;), crs=4326) %&gt;% group_by(group) %&gt;% summarise(do_union=FALSE) %&gt;% st_cast(&quot;LINESTRING&quot;) #&gt; group geometry #&gt; &lt;dbl&gt; &lt;LINESTRING [°]&gt; #&gt; 1 1 (-104.627 38.2476, -104.6506 38.30726, -104.6641 38.33735...) #&gt; 2 2 (-87.7354 42.0154, -88.8135 41.62707, -89.64513 41.35496 ...) #&gt; 3 3 (-72.9263 40.953, -72.95451 40.95169, -72.98361 40.94916 ...) Now the fbundle2 is a line shapefile! We can either export to GIS for further editing or map it using tmap package. See Base Map on how to create bg background base map and us_states boundary shapefiles. tmap_mode(&#39;plot&#39;) tm_shape(bg) + tm_rgb() + tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(fbundle2) + tm_lines(lwd=0.5, alpha=0.3, col=&#39;#1B665D&#39;) + tm_shape(MafiaSpatial %&gt;% arrange(desc(degree))) + tm_symbols(size=&quot;degree&quot;, scale=2, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;)) The bundling effect is most obvious when you contrast lines going from Florida to New York. Several edges have been bundled together. However, you can also see some unnatural bends from lines going from Florida to New York City. That is because the lines were bended halfway. In our case of the mafia map, we are not sure the edge bundling improves the visual. Again, edge bundling should be applied with cautions and experiments. "],
["advanced-ssn-metrics.html", "Chapter 6 Advanced SSN Metrics 6.1 Network Modularity 6.2 SSN Hot Spot Detection", " Chapter 6 Advanced SSN Metrics 6.1 Network Modularity 6.2 SSN Hot Spot Detection "],
["edges.html", "Chapter 7 Future Development", " Chapter 7 Future Development The development of this tutorial is funded under NSF Career Grant: A Research and Educational Framework for Incorporating Spatial Heterogeneity into Social Network Analysis. The future development of the tutorial includes: Advanced Aesthetics Export Small Multiples Base Map Inset Map Edge Arc Edge Bundling Advanced Metrics Community Detection Compare Nx Range and Density Network HotSpot Detection Clustering of Connected Nodes Isochrome Flatterning Ratio Linked Activity Space "]
]
