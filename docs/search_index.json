[["index.html", "Spatial Social Networks (SSN) Visualization and Metrics with R Chapter 1 Introduction", " Spatial Social Networks (SSN) Visualization and Metrics with R Xiaofan Liang, Clio Andris, Dipto Sarkar 2023-05-01 Chapter 1 Introduction This tutorial is dedicated to describe the basic concepts, methods, and visualizations involved to map and analyze non-planar networks (social networks &amp; relationships) in geographic space using R. A non-planar network is a network in which the nodes are geolocated, while the edges can cross over each other without creating new nodes. For example, mapping Facebook friendships and flight routes in geographic space are non-planar. A planar network is spatially embedded in a way that the edges intersect only at the endpoints, such as the road, river, and eletrical grid networks. There are already some tutorials for mapping and analyzing planar networks, but none exists for non-planar networks. We assume our audience has basic knowledge of R programming with tidyverse syntax and basic GIS concepts (e.g., basic geometry types, coordinate system projection, spatial operation etc.). If not, you can use this book Geocomputation with R to get started with the basic concepts. The book also leverages tmap at map visualization. Mapping relationship in geographic space has its own challenges, which is described thoroughly in Andris’s paper Challenges for Social Flows. In our visualization examples, we will try to show the best practices to map social networks in space that can counter some of these problems. All the data you need to complete the tutorial can be loaded from SSNtools R package, which is developed together with this tutorial. Required Packages We use igraph package to calculate network metrics, sf package to create geospatial objects from dataframe, tmap package to create both static and interactive maps, basemaps package to extract OpenStreetMap basemaps, and tidyverse package as the syntax to process data. You can download the packages using the following codes: install.packages(&quot;igraph&quot;) #for network analysis install.packages(&quot;sf&quot;) #for spatial objects operation install.packages(&quot;tmap&quot;) #for interactive and static maps install.packages(&quot;basemaps&quot;) #for retrieving basemaps for tmap install.packages(&quot;tidyverse&quot;) #for data processing install.packages(&#39;tigris&#39;) #for loading TIGER shapefiles install.packages(&#39;stplanr&#39;) #for using od2line function to convert points to lines install.packages(&#39;ggplot2&#39;) #for visualizing statistical graphics install.packages(&quot;devtools&quot;) #to download R package on GitHub devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) #install development version of our SSNtools R package for advanced SSN metrics. There are a few packages for visualizing maps. We chose tmap in the end for its flexibility to switch between interactive maps and static plots. We also have some codes that use ggplot2 to generate other graphic visualizations. ggplot2 has powerful mapping functions. It is intuitive for people who are used to the underlying logic of ggplot2. One advantage of ggplot2 is that it can easily add high-resolution Google Maps as basemaps using ggmap package (only in WGS84 projection). Here are some good tutorials that teach you how to use ggplot2 to map planar networks and produce basic elements of a map. However, you need to convert spatial objects to dataframe for ggpplot2 to draw on. tmap is equally powerful as ggpplot2, and has the extra function to switch between a static plot and interactive plot mode. This feature is useful when you want to zoom in and out to explore your data. sf converts data frame into spatial objects that can be used in base R plot function and tmap. It can also conduct various spatial operation, such as coordinate system projection, spatial joins, and topological relations. A brief introduction of how to streamline sf and tmap is given in the book Geocomputation with R. igraph is the go-to package for network analysis, such as calculating the centrality measures of a network. These measures may become the attributes for nodes or edges in the maps (see Chapter 3). tidyverse provides a set of packages that share the same data representation and use the pip symbol %&gt;% to connect steps of processing. tigris download geographic boundary shapefiles from TIGER website. stplanr is an R package that analyze planar spatial network. We mostly use the od2line() function in the package to convert points to lines. SSNtools is an R package that provides advanced metrics for analyzing and visualizing spatial social networks. It also include all the sample data we use in the tutorial. "],["metrics.html", "Chapter 2 Network Metrics 2.1 Network Data Formats 2.2 Network Metrics 2.3 igraph Visualization", " Chapter 2 Network Metrics In this chapter, we introduce the following topics: Data formats of network data Network metrics for nodes and edges How to visualize an igraph network graph We only introduce basic concepts here for reference. If you want to learn more about visualizing abstractions of networks (which are not geographically embedded) and network metrics, Katherine Ognyanova has an awesome tutorial here. 2.1 Network Data Formats Nodes and edges are the two key components of a network. Nodes may also refer as vertices (vertex for singular). There are two common data formats to store data for nodes and edges. The first one is an adjacency matrix (see 2.1 as an example), and the second one is a node table and an edge list (see 2.2 and 2.3 as an example). In a node table, one row contains all the attributes (e.g., degree, coordinates, values) for one node. In an edge table, one row represents an edge pair and all the attributes associated with the edge (e.g., weight). The following examples show data formats for a network using remittance data between China, Mexico, and Canada. Table 2.1: Adjacency Matrix China Mexico Canada China 0 48520 4144020 Mexico 2520 0 155790 Canada 19650 8980 0 Table 2.2: Node table Node_id Country_name Population_estimate Longitude Latitude 1 China 1338612970 103.11 35.69 2 Mexico 111211789 -102.18 23.73 3 Canada 33487208 -96.09 57.89 Table 2.3: Edge list Edge_id Origin Destination Remittance 1 China China 0 2 China Mexico 2520 3 China Canada 19650 4 Mexico China 48520 5 Mexico Mexico 0 6 Mexico Canada 8980 7 Canada China 4144020 8 Canada Mexico 155790 9 Canada Canada 0 2.2 Network Metrics igraph package provides functions that calculate a few network metrics for nodes and edges in an network. It can construct a network from the two common data formats: using graph_from_data_frame with a node table and an edgelist (edgelist alone works too) or graph_from_incident_matrix with an adjacency matrix. g = graph_from_data_frame(YOUR_EDGELIST, directed=TRUE) g = graph_from_data_frame(YOUR_EDGELIST, vertices=YOUR_NODETABLE, directed=TRUE) g = graph_from_incident_matrix(YOUR_MATRIX, directed=TRUE) Here are some common network metrics that are used to measure properties of nodes, edges, and network structure as a whole: 2.2.1 Network Metrics for Nodes Degree: measures the total connections of a node, regardless of the direction of the connections. V(g)$degree = degree(g, v=V(g), mode=c(&#39;all&#39;)) #add degree to nodes in the network g In Degree measures the total connections that flow to a node. V(g)$degree = degree(g, v=V(g), mode=c(&#39;in&#39;)) #add in degree to nodes in the network g Out Degree measures the total connections that flow out from a node. V(g)$degree = degree(g, v=V(g), mode=c(&#39;out&#39;)) #add out degree to nodes in the network g Weighted Degree measures the sum of the edge weights to a node, which is correlated with the degree of a node but weighted. The weighted in degree and weighted out degree use the same code, but change the mode to “in” and “out”. #Edgelist should include weight column for the code to work. V(g)$weighted_degree = strength(g, v=V(g), mode=c(&#39;all&#39;)) #add weighted degree to nodes in the network g Closeness Centrality measures the closeness of one node to all other nodes in the network. A high value means that a node, on average, can reach all other nodes in a few steps. It is calculated as the reciprocal of the sum of the length of the shortest path between a node and all other nodes in the graph. V(g)$closeness_centrality = closeness(g, vids=V(g), mode=&#39;in&#39;) #add closeness centrality (mode = &#39;in&#39; uses in degree as paths to a node) to nodes in the network g Betweenness Centrality measures the importance of a node in calculating the shortests paths of all nodes in a network. A high value means that a node, if removed from the network, will make the shortest path calculation longer for many other nodes in the network. It is calculated as the number of shortest paths that pass through the node. V(g)$betweenness_centrality = betweenness(g, v=V(g), directed=TRUE) #add betweenness centrality to nodes in the network g Eigenvector Centrality (sometimes called PageRank Centrality) measures the influence a node has on a network. A node has high influence if it is connected to many nodes who themselves have high influences. V(g)$eigenvector_centrality = eigen_centrality(g, directed=TRUE)$vector #add eigenvector centrality to nodes in the network g (Local) Clustering Coefficient measures how close the neighbors of a node all connect to each other, and thus how embedded a node is in its local networks. It is also called the local clustering coefficient. V(g)$clustering_coefficient = transitivity(g, type=&#39;local&#39;) #add local clustering coefficient to nodes in the network g Eccentricity measures the shortest path distance to the farthest other node in the network. V(g)$eccentricity = eccentricity(g, vids=V(g), mode=c(&#39;all&#39;)) #add eccentricity to nodes (path calculated as undirected) in the network g Shortest Path is the shortest path from one node to another in the network. It contains a list of nodes that the path passes by. get.shortest.paths(g, 1, 3) #give you the shortest path from node 1 to node 3. The path will show the number or the name of the nodes passed. Igraph package labels every node with a number. Hops is the number of steps for one node to jump to another node. length(get.shortest.paths(g, 1, 3)$vpath[[1]]) #measure the number of hops from node 1 to node 3 2.2.2 Network Metrics for Edges Weight can represent the value of the connection, such as volumes of flows or the extent of strength (e.g., trust). E(g)$weight = YOUR_WEIGHT_VECTOR #assign weights to edges Edge Betweenness measures the number of shortest paths pass through an edge. E(g)$edge_betweenness = edge_betweenness(g, e=E(g), directed=TRUE) #calculate edge_betweenness for all edges in a network For network structures: Diameter measures the maximum distance between any pairs of nodes in a network. In another word, it is the maximum eccentricity of any node. d = diameter(g, directed=FALSE) #calculate diameter of a network (Global) Clustering Coefficient measures the degree to which nodes in a network tend to cluster together. Global clustering coefficient is calculated as the ratio of the number of closed triplets and the total number of triplets. global_clustering_coefficient = transitivity(g, type=&#39;average&#39;) #calculate global clustering coefficient of a network Average Path Length measures the mean of the lengths of the shortest paths between all pairs of nodes in the network. avg_path_length = average.path.length(g, directed=FALSE) #calculate the average path length of a undirected network 2.3 igraph Visualization Here is an example using data about the American Mafia to visualize an igraph network. This data was collected by Dan DellaPosta at Penn State and published in the paper Network closure and integration in the mid-20th century American mafia. The node table contains: Name of the Mafia member Mafia family the member belongs to Whether the member is in New York City Longitude and Latitude of the location of the member The edge list contains pairs of undirected connections: Source (the name of a member) Target (the name of a different member) The node size varies by the values of local clustering coefficient, and the node color varies by the mafia family the node belongs to. library(igraph) library(SSNtools) #MafiaNodes and MafiaEdges are built-in datasets in SSNtools package data(MafiaNodes) data(MafiaEdges) #convert networkd data to an igraph object g &lt;- graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaNodes) #set the node size to base on clustering coefficients V(g)$size &lt;- transitivity(g, type=&#39;local&#39;) #delete vertices that do not have clustering coefficients g = delete_vertices(g, is.na(V(g)$size)) #Set the node color to vary by mafia family group. # ---- get all color from a color device color = grDevices::colors()[grep(&#39;gr(a|e)y&#39;, grDevices::colors(), invert = T)] # ---- sample n color, in which n = family groups colrs &lt;- sample(color, length(unique(V(g)$Family))) # ---- #assign color to correpsonding mafia family member V(g)$color &lt;- colrs[as.numeric(factor(V(g)$Family))] #Plot igraph network plot(g, vertex.label = NA, vertex.color = V(g)$color, vertex.size = 10*V(g)$size, #Scaled node size edge.width=0.5, layout=layout_with_fr(g) ) #Add node color legend fname = sort(unique(V(g)$Family)) #sort the legend labels legend(x=-2.2, y=1.5, #legend position legend=fname, pch=21, #solid circle with one color pt.bg=colrs[as.numeric(factor(fname))], pt.cex=1, cex=.7, bty=&quot;n&quot;, ncol=1, title = &#39;Node Color: Family Group&#39; ) #Add node size legend # ---- quantile breaks to show node size breaks = round(quantile(V(g)$size, c(0.2, 0.4, 0.6, 0.8, 1)),2) legend(x = -2.2, y = -1.2, #legend position legend=breaks, pch=21, pt.bg=NA, #no color background cex=0.7, #size of legend pt.cex=breaks * 2, #Scaled node size bty=&quot;n&quot;, #node shape ncol=5, #number of column for legend text.width = 0.27, #adjust width of each column title = &#39;Node Size: Local Clustering Coefficient&#39;) "],["nodes.html", "Chapter 3 Visualizing Nodes 3.1 Convert Coordinates to Points 3.2 Visualize Nodes 3.3 Visualize Nodes by Node Color 3.4 Visualize Nodes by Node Size 3.5 Visualize Nodes by Size and Color", " Chapter 3 Visualizing Nodes In this chapter, we continue to use the American Mafia data introduced in Chapter 2. They can be loaded from the SSNtools package directly. The node table MafiaNodes contains: NODE: Name of the Mafia member (capitalized) Family: Mafia family the member belongs to NY: Whether the member is in New York City LonX: Longitude of the location of the member LatY: Latitude of the location of the member NiceLabel: Name of the Mafia member (lower case) The edge list MafiaEdges contains pairs of undirected connections: Source: the name of a member Target: the name of a different member This chapter covers the following topics: How to convert node coordinates into point geometry How to visualize nodes with constant color and size How to visualize nodes with varying node size by attributes How to visualize nodes with varying color by attributes How to visualize nodes with varying node size and color with a combined legend You will be able to find a copy of all the codes at the bottom of the page. Before proceeding to the codes, please load the following packages: library(sf) library(tidyverse) library(tmap) library(igraph) library(RColorBrewer) library(tigris) #install.packages(&quot;devtools&quot;) #to download R package on GitHub #devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) library(SSNtools) 3.1 Convert Coordinates to Points The data for the nodes may come in two common format. One is the node table that we mentioned in Chapter 2 (REF), and the other is spatial object, in which nodes are already point geometry. The node table often stores the spatial information of the node as two columns: latitude and longitude. Spatial object contains spatial information of the node in the geometry column. It also includes projection coordinates system of the object. Unless you are working with ggplot2, most other visualization packages require nodes to be spatial objects for mapping. You can convert a node table with coordinates into a spatial object with st_as_sf function in sf package. Spatial information is stored in the LonX and LatY column in MafiaNodes node table. Therefore, when we convert it to sf spatial object, we need to set the coordinates crs to be WGS84 (4326). #MafiaNodes is a built-in dataset in SSNtools R package data(MafiaNodes) MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) head(MafiaSpatial, 3) ## Simple feature collection with 3 features and 4 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -117.291 ymin: 34.1493 xmax: -77.5774 ymax: 43.1356 ## Geodetic CRS: WGS 84 ## NODE Family NY NiceLabel geometry ## 1 VALENTI-COSTENZA Bonanno 1 Costenza Valenti POINT (-77.6064 43.1349) ## 2 VALENTI-FRANK Bonanno 1 Frank Valenti POINT (-77.5774 43.1356) ## 3 DIPOLLITO-JOSEPH Los_Angeles 0 Joseph Dipollito POINT (-117.291 34.1493) 3.2 Visualize Nodes First step, we download the U.S. state shapefile through tigris package as the background for visualization and transform the shapefile and the dataframe data to the appropriate crs (coordinate reference system). The coordinate information can be stored in other projection system other than the commonly used WGS84. Users need to find out what crs is used before transforming the data to another system. Only when crs are the same for two or more shapefiles (or geometry) can we overlay them correctly on each other. Since we are mapping the data on U.S. mainland, we exclude U.S. territories and further transform the node table into sf spatial objects with North America Equidistant Conic projection (crs=“ESRI:102010”). #Convert coordinate system MafiaSpatial = MafiaSpatial %&gt;% st_transform(MafiaSpatioal, crs=&quot;ESRI:102010&quot;) #states is a function in tigris to download U.S. state boundary shapefile us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) %&gt;% st_transform(crs=&quot;ESRI:102010&quot;) Second step: visualize the nodes on the US state map! tmap_mode(&#39;plot&#39;) # set tmap plotting mode to static map tm_shape(us_states) + tm_polygons() + #draw U.S. state shapefile first as polygons tm_shape(MafiaSpatial) + tm_symbols() #overlay nodes as points 3.3 Visualize Nodes by Node Color The map above only shows the locations of Mafia members. We want to visualize the influence of these members and find out where influential people reside. We load the edge file MafiaEdges and calculate the degree of each node. To vary the node color by degree, we simply set the col argument to the variable degree that should vary by color. Different from node size, style argument can modulate the breaks for node color in different styles, such as quantile breaks, equal interval breaks, head/tail breaks and so on. The number of class is defaulted to five. To define the color, you can either pass a R palette (e.g., YlGnBu) or a vector of color to palette argument. More details can be found in tmap document. #MafiaEdges is a built-in dataset in SSNtools #Construct a network and calculate the degree for each node. g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( size=1, #constant node size col=&#39;degree&#39;, palette = &#39;YlGnBu&#39;, #define which numeric column to vary by color and the color palette style=&#39;quantile&#39;, n = 4, #define the color breaks using quantile, and set the number of classes to 4. alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, title.col=c(&#39;Degree of Connections&#39;)) 3.4 Visualize Nodes by Node Size To visualize the node size by the connection degree, we have to set the node size varies by degree in tm_symbols. The default breaks for node size is interval breaks. You can adjust the breaks for node size in the legend directly through sizes.legend argument in tm_symbols. # Visualize tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + #turn the background color of the polygons to transparent tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, #scale up the node size col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) If you want node size to follow a particular break, then nodes need to be grouped into size brackets. Differnt from color whose breaks can be adjusted in style argument (e.g., style=‘quantile’), changing node size is not straightforward. This example shows how to size nodes in quantile breaks. We first check the quantile breakdown of the degree in the data as the reference. Then, we create a new degree_brackets column that group nodes with different degree to ordered categories. Lastly, we set the size argument in tm_symbols to the new degree_brackets column, which changes the size of the nodes in the map. We adjust the legend breaks using sizes.legend. sizes.legend only changes the size of the nodes in the legend but not for nodes in the map (use scale for the latter). More details can be found in tmap document. The final node size in the map = relative node size defined in degree_brackets / size.max * scale Numbers in the degree_brackets column only define the relative size difference between the nodes. size.max and scale are often defaulted to be 1, therefore makes it easy for people to directly define node size in the degree_brackets column. In that case, the node with designated with the highest size value will have the node size of 1. In our example, node size of 1 is visually too small in the map, so we scale up the node size by 1.5. Thus, the actual node sizes for the four brackets are c(0.1, 0.3, 0.5, 1)/1*1.5 = c(0.15, 0.45, 0.75, 1.5). quantile(MafiaSpatial$degree) ## 0% 25% 50% 75% 100% ## 1 4 6 10 77 # Create a new &#39;degree_bracket&#39; column that contains the node size for each group of nodes. MafiaSpatial = MafiaSpatial %&gt;% mutate(degree_brackets = case_when( degree &gt;= 2 &amp; degree &lt; 8 ~ 0.1, degree &gt;= 8 &amp; degree &lt; 12 ~ 0.3, degree &gt;= 12 &amp; degree &lt; 20 ~ 0.5, degree &gt;= 20 &amp; degree &lt;= 154 ~ 1 )) # Visualize tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, sizes.legend = c(0.1, 0.3, 0.5, 1)/1*1.5, sizes.legend.labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, #blue grey alpha=0.5, border.alpha = 0.5, title.size=c(&#39;Degree of Connections&#39;)) 3.5 Visualize Nodes by Size and Color The automatic legend in tmap now cannot support color and size legend in one. To combine the color and size legend, we have to manually create a legend with the color and size attributes from the color and size legends, using tm_add_legend. To replicate the color, we use RColorBrewer package to generate colors for a given number, which is the default way that tmap assigns colors. To replicate the size, we pass in the square root of the actual node size. Setting node size in tm_add_legend is tricky, which is the square roots of the actual node size (see here for detail explanation). Remember: The final node size in the map = relative node size defined in degree_brackets / size.max * scale. Lastly, we set the legend.col.show =FALSE and legend.size.show =FALSE to hide the default legends. tmap_mode(&#39;plot&#39;) map = tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( #arguments that define point sizes size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, legend.size.show = FALSE, #arguments that define point colors col=&#39;degree_brackets&#39;, palette = &#39;YlGnBu&#39;, n = 4, alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, legend.col.show = FALSE) + tm_add_legend(type=c(&quot;symbol&quot;), col = c(&quot;#FFFFCC&quot;, &quot;#A1DAB4&quot;, &quot;#41B6C4&quot;, &quot;#225EA8&quot;), #copy from RColorBrewer: brewer.pal(4, &quot;YlGnBu&quot;) alpha = 0.5, is.portrait = FALSE, # legend becomes horizontal # size defined here should be the square root of the normalized point size * scale. # The square root is taken since the area is proportional to the data, not the radius. size = (c(0.1,0.3,0.5,1)/1)^0.5*1.5, labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), #break labels border.col = &#39;black&#39;, border.alpha = 0.2, title = c(&quot;Degree of Connections&quot;)) map To export the tmap object into a local folder, you can add: tmap_save(map, filename=&#39;YOUR_LOCAL_FOLDER_PATH/map.png&#39;) The full codes for creating the map above is in the following: library(readr) library(igraph) library(tmap) library(sf) library(tidyverse) library(RColorBrewer) library(SSNtools) #read data MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) us_states = states(cb=TRUE, progress_bar=FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) %&gt;% st_transform(crs=&quot;ESRI:102010&quot;) # Construct a network and calculate the degree for each node. g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) # Create a new column that assign point size to points with varying degree. MafiaSpatial = MafiaSpatial %&gt;% mutate(degree_brackets = case_when( degree &gt;= quantile(MafiaSpatial$degree)[1] &amp; degree &lt; quantile(MafiaSpatial$degree)[2] ~ 0.1, degree &gt;= quantile(MafiaSpatial$degree)[2] &amp; degree &lt; quantile(MafiaSpatial$degree)[3] ~ 0.3, degree &gt;= quantile(MafiaSpatial$degree)[3] &amp; degree &lt; quantile(MafiaSpatial$degree)[4] ~ 0.5, degree &gt;= quantile(MafiaSpatial$degree)[4] &amp; degree &lt;= quantile(MafiaSpatial$degree)[5] ~ 1 )) # Visualize tmap_mode(&#39;plot&#39;) map = tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( #arguments that define point sizes size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, legend.size.show = FALSE, #arguments that define point colors col=&#39;degree&#39;, palette = &#39;YlGnBu&#39;, style=&#39;quantile&#39;, n = 4, alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, legend.col.show = FALSE) + tm_add_legend(type=c(&quot;symbol&quot;), col = brewer.pal(4, &quot;YlGnBu&quot;), #copy the color from R palette alpha = 0.5, is.portrait = FALSE, # legend becomes horizontal # size defined here should be the sqaure root of the normalized point size * scale. # The square root is taken since the area is proportional to the data, not the radius. size = (c(0.1,0.3,0.5,1)/1)^0.5*1.5, labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), #break labels border.col = &#39;black&#39;, border.alpha = 0.2, title = c(&quot;Degree of Connections&quot;)) #tmap_save(map, filename=&#39;YOUR_LOCAL_FOLDER_PATH/map.png&#39;) "],["vizedges.html", "Chapter 4 Visualizing Edges 4.1 Convert Points into Lines 4.2 Visualizing Edges 4.3 Visualizing Edges by Line Width 4.4 Visualizing Edges by Color 4.5 Visualizing Edges by Width and Color", " Chapter 4 Visualizing Edges In this chapter, we continue to use the American Mafia data introduced in Chapter 2. This chapter covers the following topics: How to convert point data into line geometry How to visualize edges with constant color and size How to visualize edges with varying edge width by attributes How to visualize edges with varying edge color by attributes How to visualize edges with varying edge size and edge color with a combined legend You will be able to find a copy of all the codes at the bottom of the page. Before proceeding to the codes, please load the following packages: library(sf) #for using spatial objects library(tidyverse) #for using tidy syntax library(tmap) #for visualizing maps library(tigris) #for downloading TIGER boundary shapefiles library(stplanr) #for using od2line function to convert points to lines library(igraph) #for calculating node degree library(SSNtools) #load sample datasets MafiaNodes and MafiaEdges 4.1 Convert Points into Lines 4.1.1 Method 1: Use od2line function in stplanr package. od2line takes in two arguments: 1) an OD dataframe that assumes the first two column contains the origin and destination variables, and 2) a shapefile that can be matched to the origin and destinations. In our case, the first dataframe is MafiaEdges, and the second is MafiaNodes converted into an sf geometry object. This method is particularly useful if you stores your OD dataframe and your shapefile separately. This is also the easiest way for our dataset to convert into lines. The only downside is that you have one more package dependency. We encourage readers to explore other useful OD-related functions in the stplanr package, such as dist_google(), od_coords2line(), od_to_odmatrix() and so on. #library(SSNtools) #library(tidyverse) #library(stplanr) data(MafiaNodes) data(MafiaEdges) # convert MafiaNodes to an sf geometry object (shapefile) MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) # create line geometry MafiaEdges_toLine = od2line(MafiaEdges, MafiaSpatial) # print first three rows MafiaEdges_toLine[c(1:3),] ## Simple feature collection with 3 features and 2 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -80.1252 ymin: 25.9783 xmax: -73.9652 ymax: 40.7449 ## Geodetic CRS: WGS 84 ## Source Target geometry ## 1 CARUSO-FRANK LISI-GAETANO LINESTRING (-74.0049 40.613... ## 2 LANSKY-MEYER GAMBINO-CARLO LINESTRING (-80.1252 25.978... ## 3 CARUSO-FRANK DIMAGGIO-ROSARIO LINESTRING (-74.0049 40.613... 4.1.2 Method 2: Group by lineID and Summarize Points into Line The second one is to group the points coordinates by line ID, summarize the geometry (you can also flow values in the same statement if available), and then use st_cast in the sf package to turn the grouped point coordinates into a line geometry. This method is particularly useful if your points are organized by line ID and if you do not want to use extra packages. It is also convenient for visualizing GPS trajectory data because each row tends to be a point data associated with a line ID and you want to connect all the points that represent one trajectory. For our data, we do not have line ID for points, but for demonstration purpose, we can create such ID with row_number(). Then we use pivot_longer() in tidyr package (loaded with tidyverse) to transform one row of edge to two rows of edge points and show what the data look like. Noted that multiple mafia members in MafiaNodes have the same locations and are connected. They cannot form lines. Thus we remove them in the codes. #library(SSNtools) #library(tidyverse) #library(sf) data(MafiaNodes) data(MafiaEdges) # convert MafiaNodes to an sf geometry object (shapefile) MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) # transform MafiaEdges to a format where each node in the edge is coded with an edge ID MafiaEdges2 = MafiaEdges %&gt;% mutate(ID = row_number()) %&gt;% pivot_longer(cols = c(&quot;Source&quot;, &quot;Target&quot;), names_to = &quot;type&quot;, values_to = &quot;NODE&quot;) %&gt;% left_join(MafiaSpatial, by=c(&#39;NODE&#39;), copy=FALSE) # print first three rows of the data MafiaEdges2[c(1:3),] ## # A tibble: 3 × 7 ## ID type NODE Family NY NiceLabel geometry ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;POINT [°]&gt; ## 1 1 Source CARUSO-FRANK Genovese 2 Frank Caruso (-74.0049 40.6133) ## 2 1 Target LISI-GAETANO Lucchese 2 Gaetano Lisi (-73.9908 40.7142) ## 3 2 Source LANSKY-MEYER Genovese 1 Meyer Lansky (-80.1252 25.9783) # convert points to lines MafiaEdges_toLine = MafiaEdges2 %&gt;% group_by(ID) %&gt;% # this is an optional step to remove points that are at the same location; filter(n_distinct(geometry) &gt; 1) %&gt;% st_as_sf() %&gt;% group_by(ID) %&gt;% summarise() %&gt;% st_cast(&quot;LINESTRING&quot;) MafiaEdges_toLine[c(1:4),] ## Simple feature collection with 4 features and 1 field ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -118.157 ymin: 25.9783 xmax: -73.9652 ymax: 40.7449 ## Geodetic CRS: WGS 84 ## # A tibble: 4 × 2 ## ID geometry ## &lt;int&gt; &lt;LINESTRING [°]&gt; ## 1 1 (-74.0049 40.6133, -73.9908 40.7142) ## 2 2 (-80.1252 25.9783, -73.9652 40.595) ## 3 3 (-74.0049 40.6133, -73.985 40.7449) ## 4 4 (-118.157 33.9231, -117.93 34.0768) 4.1.3 Method 3: Join Two Point Geometry into One Row and Unite into Line The third way to convert points into lines is to join two point geometry in one row and cast them into a line. This method is particularly useful if you have coordinates of both origin and destination points in one dataframe. In our case, we do not have coordinates, so we have to join MafiaNodes to get the geometries to use this method. #library(SSNtools) #library(tidyverse) #library(sf) data(MafiaNodes) data(MafiaEdges) # attach point geometry to MafiaEdges for both Source and Target nodes MafiaEdges_toLine = MafiaEdges %&gt;% left_join(MafiaNodes, by=c(&#39;Source&#39; = &#39;NODE&#39;), copy=FALSE) %&gt;% left_join(MafiaNodes, by=c(&#39;Target&#39; = &#39;NODE&#39;), copy=FALSE) %&gt;% #LonX.x and LatY.x are coordinates for Source; #LonX.y and LatY.y are coordinates for Target select(c(Source, Target, LonX.x, LatY.x, LonX.y, LatY.y)) %&gt;% # this is an optional step to remove points that are at the same location filter(LonX.x != LonX.y &amp; LatY.x != LatY.y) # this helper function converts a row with four coordinates into a # two by two matrix and cast it into a linestring. st_segment = function(r){st_linestring(t(matrix(unlist(r), 2, 2)))} # loop through each row and cast it into a linestring MafiaEdges_toLine$geometry = st_sfc( sapply(1:nrow(MafiaEdges_toLine), function(i){ st_segment(MafiaEdges_toLine[i,][c(&#39;LonX.x&#39;, &#39;LatY.x&#39;, &#39;LonX.y&#39;, &#39;LatY.y&#39;)])}, simplify=FALSE)) # ensure the output is an sf object and set the crs MafiaEdges_toLine = MafiaEdges_toLine %&gt;% st_as_sf() %&gt;% st_set_crs(4326) MafiaEdges_toLine[c(1:3),] ## Simple feature collection with 3 features and 6 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -80.1252 ymin: 25.9783 xmax: -73.9652 ymax: 40.7449 ## Geodetic CRS: WGS 84 ## Source Target LonX.x LatY.x LonX.y LatY.y ## 1 CARUSO-FRANK LISI-GAETANO -74.0049 40.6133 -73.9908 40.7142 ## 2 LANSKY-MEYER GAMBINO-CARLO -80.1252 25.9783 -73.9652 40.5950 ## 3 CARUSO-FRANK DIMAGGIO-ROSARIO -74.0049 40.6133 -73.9850 40.7449 ## geometry ## 1 LINESTRING (-74.0049 40.613... ## 2 LINESTRING (-80.1252 25.978... ## 3 LINESTRING (-74.0049 40.613... 4.2 Visualizing Edges The simplest edge visualization code snippet using tmap is the following: #library(SSNtools) #library(tidyverse) #library(sf) #library(tmap) #library(tigris) # prepare data data(MafiaNodes) data(MafiaEdges) # convert coordinates to sf point geometries MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) # convert point geometries to lines MafiaEdges_toLine = od2line(MafiaEdges, MafiaSpatial) # states is a function in tigris to download U.S. state boundary shapefile us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) # tmap functions to visualize maps tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons() + tm_shape(MafiaEdges_toLine) + tm_lines() 4.3 Visualizing Edges by Line Width To visualize edges by line width, we added a column variable weight for line width in tm_lines(). # create a line weight column based on edge distance MafiaEdges_toLine = MafiaEdges_toLine %&gt;% mutate(weight = as.numeric(st_length(geometry))) #library(tmap) tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0, border.col = &#39;grey&#39;) + tm_shape(MafiaEdges_toLine) + #define line width with column `weight` and properties associated with lines tm_lines(lwd=&#39;weight&#39;, scale=2, alpha=0.2, legend.lwd.is.portrait = TRUE, title.lwd = c(&#39;Distance (m)&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;bottom&#39;)) The default line width setting is proportional to the column variable (in this case, weight values). In reality, the degree weight distribution of non-planar networks is often skewed, with a few edges have very high weights or flow values and most of the rest have low values. Therefore, we need to adjust the breaks to better visualize the SSN network. To adjust the line width breaks, we need to create a column to store relative edge width, which is similar to the node size visualization in chapter 2. We chose a skewed quantile breaks for line width. This step is quite manual for line width aesthetics, and better supported for color aesthetics. The upcoming tmap v4 will have significant improvements on the ease of use. # We create a column called flow_breaks that stores relative line width brks = round(quantile(MafiaEdges_toLine$weight, probs=c(0, 0.5, 0.9, 0.99, 1)), 0) MafiaEdges_toLine = MafiaEdges_toLine %&gt;% mutate( line_width = case_when( weight &gt;= brks[1] &amp; weight &lt;= brks[2] ~ 0.1, weight &gt; brks[2] &amp; weight &lt;= brks[3] ~ 0.3, weight &gt; brks[3] &amp; weight &lt;= brks[4] ~ 0.5, weight &gt; brks[4] &amp; weight &lt;= brks[5] ~ 1 ) ) tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0, border.col = &#39;grey&#39;) + tm_shape(MafiaEdges_toLine) + #define line width with column `weight` and properties associated with lines tm_lines(lwd=&#39;line_width&#39;, scale=2, alpha=0.2, legend.lwd.is.portrait = TRUE, lwd.legend = c(0.1, 0.3, 0.5, 1)*2, lwd.legend.labels=c(&#39;0-14&#39;,&#39;14-1630&#39;,&#39;1630-4000&#39;,&#39;4000-4150&#39;), title.lwd = c(&#39;Distance (km)&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;bottom&#39;)) 4.4 Visualizing Edges by Color To visualize edges by color, we assign the variable column weight to argument col in tm_lines. Since we already established that the edges are better viewed through a skewed flow breaks, we manually assign break values for color. To do that, we give argument breaks a vector of fixed numbers, and set argument style to fixed. The following map has constant line width across different colors. tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0, border.col = &#39;grey&#39;) + #reorder edges so that long distance edges are drawn first and short-ranged edges drawn last tm_shape(arrange(MafiaEdges_toLine, desc(weight))) + #define line color with column `weight` and properties associated with lines tm_lines(col=&#39;weight&#39;, scale=2, alpha=0.2, breaks = round(quantile(MafiaEdges_toLine$weight, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, labels=c(&#39;0-14&#39;,&#39;14-1630&#39;,&#39;1630-4000&#39;,&#39;4000-4150&#39;), palette=c(&#39;#CCEBC5&#39;, &#39;#7BCCC4&#39;, &#39;#2B8CBE&#39;, &#39;#094081&#39;), title.col = c(&#39;Distance (km)&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;bottom&#39;)) We can also visualize lines by color based on a categorical variable, such as mafia families. To create assign a categorical value to each edge, we identified the top 5 mafia families with the most number of members. They are ‘Genovese’, ‘Lucchese’, ‘Gambino’, ‘Detroit’, and ‘Chicago’. If an edge is affiliated with one of the top 5 mafia families, it will be joined with the respective mafia family name. Otherwise, it will has the value Others. The biggest difference with the codes above is to change style = 'fixed' to style = 'cat' in tm_lines() and change the color palette to represent categorical colors. top_5 = c(&#39;Genovese&#39;, &#39;Lucchese&#39;, &#39;Gambino&#39;, &#39;Detroit&#39;, &#39;Chicago&#39;) MafiaNodes = MafiaNodes %&gt;% mutate(Family = ifelse(Family %in% top_5, Family, &#39;Others&#39;)) MafiaEdges_toLine = MafiaEdges_toLine %&gt;% left_join(MafiaNodes %&gt;% select(c(NODE, Family)), by=c(&#39;Source&#39; = &#39;NODE&#39;), copy=FALSE) %&gt;% left_join(MafiaNodes %&gt;% select(c(NODE, Family)), by=c(&#39;Target&#39; = &#39;NODE&#39;), copy=FALSE) %&gt;% #the two left join above will automatically create Family.x and Family.y to differentiate having `Family` twice. mutate(edge_family = ifelse(Family.x %in% top_5, Family.x, &#39;Others&#39;)) %&gt;% mutate(edge_family = ifelse(Family.y %in% top_5, Family.y, edge_family)) tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0, border.col = &#39;grey&#39;) + tm_shape(arrange(MafiaEdges_toLine, desc(edge_family))) + tm_lines(col=&#39;edge_family&#39;, style=&#39;cat&#39;, alpha=0.5, lwd=1, palette=c(&#39;#57B897&#39;, &#39;#F7774F&#39;, &#39;#7A8CC1&#39;, &#39;#E072B5&#39;, &#39;#FAD324&#39;, &#39;lightgrey&#39;), title.col = c(&#39;Edges by Families&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;bottom&#39;)) 4.5 Visualizing Edges by Width and Color Similar to node visualization, to visualize edges with both line width and color, we need to add arguments for both and create a combined legend through tm_add_legend. Unfortunately, the package does not have an automatic way to combine color and line width legend together, so we have to define the values manually. tmap_mode(&#39;plot&#39;) map = tm_shape(us_states) + tm_polygons(alpha=0, border.col = &#39;grey&#39;) + #reorder edges so that long distance edges are drawn first and short-ranged edges drawn last tm_shape(arrange(MafiaEdges_toLine, desc(weight))) + tm_lines( #arguments that define the styles for color col=&quot;weight&quot;, alpha=0.2, breaks = round(quantile(MafiaEdges_toLine$weight, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, palette=c(&#39;#CCEBC5&#39;, &#39;#7BCCC4&#39;, &#39;#2B8CBE&#39;, &#39;#094081&#39;), legend.col.show = FALSE, #arguments that define the styles for line width lwd=&#39;line_width&#39;, scale=2, legend.lwd.show = FALSE ) + #add manual legends to combine color and line width schema tm_add_legend( type=c(&#39;line&#39;), col=c(&#39;#CCEBC5&#39;, &#39;#7BCCC4&#39;, &#39;#2B8CBE&#39;, &#39;#094081&#39;), lwd=c(0.1, 0.3, 0.5, 1)*2, labels=c(&#39;0-14&#39;,&#39;14-1630&#39;,&#39;1630-4000&#39;,&#39;4000-4150&#39;), title=&#39;Distance (km)&#39;) + tm_layout(legend.position = c(&#39;right&#39;, &#39;bottom&#39;)) map Perfect! Now we can would like to add nodes with size scaled by their degree. Here we show a new technique, which is to save the map we already plotted as a variable map above, and add new components to it. In this way, we do not have to regenerate the portion of the map that we already produced and speed up the mapping and testing time dramatically! #library(igraph) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) map = map + tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, #scale up the node size col=&#39;orange&#39;, border.col=&#39;darkorange&#39;, alpha=0.2, border.alpha = 0.2, title.size=c(&#39;Degree&#39;)) map To export the tmap object into a local folder, you can add: tmap_save(map, filename=&#39;YOUR_LOCAL_FOLDER_PATH/map.png&#39;) Here is the full code to replicate the map above library(sf) library(tidyverse) library(tmap) library(tigris) library(stplanr) library(igraph) data(MafiaNodes) data(MafiaEdges) # convert MafiaNodes to an sf geometry object (shapefile) MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) # create line geometry MafiaEdges_toLine = od2line(MafiaEdges, MafiaSpatial) # states is a function in tigris to download U.S. state boundary shapefile us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) # create weight column for each edge MafiaEdges_toLine = MafiaEdges_toLine %&gt;% mutate(weight = as.numeric(st_length(geometry))) brks = round(quantile(MafiaEdges_toLine$weight, probs=c(0, 0.5, 0.9, 0.99, 1)), 0) # create line_width column for each edge MafiaEdges_toLine = MafiaEdges_toLine %&gt;% mutate( line_width = case_when( weight &gt;= brks[1] &amp; weight &lt;= brks[2] ~ 0.1, weight &gt; brks[2] &amp; weight &lt;= brks[3] ~ 0.3, weight &gt; brks[3] &amp; weight &lt;= brks[4] ~ 0.5, weight &gt; brks[4] &amp; weight &lt;= brks[5] ~ 1 ) ) # create degree column for each node g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) tmap_mode(&#39;plot&#39;) map = tm_shape(us_states) + tm_polygons(alpha=0, border.col = &#39;grey&#39;) + #reorder edges so that long distance edges are drawn first and short-ranged edges drawn last tm_shape(arrange(MafiaEdges_toLine, desc(weight))) + tm_lines( #arguments that define the styles for color col=&quot;weight&quot;, alpha=0.2, breaks = round(quantile(MafiaEdges_toLine$weight, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, palette=c(&#39;#CCEBC5&#39;, &#39;#7BCCC4&#39;, &#39;#2B8CBE&#39;, &#39;#094081&#39;), legend.col.show = FALSE, #arguments that define the styles for line width lwd=&#39;line_width&#39;, scale=2, legend.lwd.show = FALSE ) + #add manual legends to combine color and line width schema tm_add_legend( type=c(&#39;line&#39;), col=c(&#39;#CCEBC5&#39;, &#39;#7BCCC4&#39;, &#39;#2B8CBE&#39;, &#39;#094081&#39;), lwd=c(0.1, 0.3, 0.5, 1)*2, labels=c(&#39;0-14&#39;,&#39;14-1630&#39;,&#39;1630-4000&#39;,&#39;4000-4150&#39;), title=&#39;Distance (km)&#39;) + tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, #scale up the node size col=&#39;orange&#39;, border.col=&#39;darkorange&#39;, alpha=0.2, border.alpha = 0.2, title.size=c(&#39;Degree&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;bottom&#39;)) #tmap_save(map, filename=&#39;YOUR_LOCAL_FOLDER_PATH/map.png&#39;) map "],["advanced-aesthetics.html", "Chapter 5 Advanced Aesthetics 5.1 Export Maps 5.2 Small Multiples 5.3 Interactive Maps 5.4 Base Map 5.5 Inset Map 5.6 Edge Bundling", " Chapter 5 Advanced Aesthetics .Code { background-color: grey; } In this chapter, we will continue to use default dataset MafiaNodes and MafiaEdges in SSNtools to illustrate examples. This chapter covers the following topics: How to export tmap objects as static images How to create small multiples with tmap How to create an interactive map and publish it online How to add a basemap to static tmap object in plot mode How to add inset map to static tmap object in plot mode How to apply edge bundling to non-planar networks in tmap You may need one or more of these libraries to complete the codes in this chapter. library(sf) #required for any functions start with`st_` library(tidyverse) #required for any process that involves `%&gt;%` library(tmap) #required for any map visualization library(SSNtools) #required for any steps that involved MafiaNodes or MafiaEdges dataset library(igraph) #required for creating network from graph_from_data_frame and calculating network metrics library(basemaps) #required for loading basemaps library(tigris) #required for downloading boundary shapefiles library(grid) #required for inset map library(stplanr) #optional for od2line function used to convert points to lines library(edgebundle) #required for edge bundling 5.1 Export Maps tmap allows users to export tmap object as a static map in the format of pdf, eps, svg, wmf, png, jpg, bmp, or tiff. You can define the resolution, height, and width of the export in the tmap_save arguments. tmap_save(tm = TMAP_OBJECT, filename=&#39;PATH/FILENAME.png&#39;) With these formats, you can import the tmap maps into Adobe Illustrators or Photoshop to further edit the details. You can also export the shapefiles you created in R to experiment in GIS softwares through sf package. #MafiaNodes is a built-in dataset from SSNtools MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) st_write(MafiaSpatial, &quot;MafiaSpatial.shp&quot;) Unfortunately, there isn’t a way to export tmap object to GIS softwares without losing the aesthetics yet (e.g., scale, size, color etc., see updates on this issue here). Another thing to note is that graphics exported through tmap_save may look different from the Plots panel in RStudio. This is because the size of the graphic elements may be scaled dependent on the attributes you put in tmap_save. 5.2 Small Multiples In our case of the Mafia connectivity map, the power of the Mafia members can be represented by different network metrics. For example, degree centrality (i.e. degree connections) measures power as the number of connections to a Mafia member. Eigenvector centrality (i.e., PageRank centrality) measures power by not only the count of connections, but also the quality of connections so that connecting to other powerful members increases the weight of the link. Betweeness centrality measures power by the ability of a Mafia member to be the “middle-man/middle-woman” and connect groups of other members that would not be connected otherwise. (Local) Clustering coefficient measures whether a Mafia member’s friends tend to connect with each others (i.e., whether your friends are also your friends’ friends). Noted that closeness centrality is also a common measure of power, but the metric is not well-defined for disconnected graphs. In our dataset, there exists small Mafia cliques that do not interact with others. Thus, we did not use this metric. To contrast these different notions of power in the Mafia map, small multiple comes in handy. Small multiple is a group of charts or graphs that use the same scale or axes for easy comparison. Here we show how to create a small multiple of the Mafia member map with various network metrics through tmap tm_facets. Before we map the small multiple, there are some pre-processing. Firstly, when we add network metrics into the MafiaSpatial, each metric is in one column. However, the tm_facet only create multiples based on a column of value. Thus, we need to convert MafiaSpatial into a long table using gather function in tidyverse package (more accuratly, the tidyr package in tidyverse) so that column metric stores the type of metrics (e.g., “degree”, “eigen”, “betweenness”, “cluster”), and the column value stores the metric value. Secondly, we convert the metric column into a factor column, so that the order of the variable to be mapped is specified. Otherwise, the order of mapping for the small multiple will follow the alphebatical order of the value string in the metric column. Lastly, we also retrieve the state boundary shapefile from tigris as the background for the map. library(sf) library(tidyverse) library(tmap) library(SSNtools) library(igraph) library(tigris) #MafiaNodes and MafiaEdges are built-in dataset from SSNtools MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) #Calculate network metrics MafiaSpatial$degree = degree(g) MafiaSpatial$eigen = eigen_centrality(g)$vector MafiaSpatial$betweenness = betweenness(g, v=V(g)) MafiaSpatial$cluster = transitivity(g, type=&#39;local&#39;) MafiaSpatial = MafiaSpatial %&gt;% gather(key=&#39;metric&#39;, value=&#39;value&#39;, degree:cluster) %&gt;% mutate(metric = factor(metric, levels=c(&#39;degree&#39;, &#39;eigen&#39;, &#39;betweenness&#39;, &#39;cluster&#39;))) #states is a function from tigris package us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) Now we can map the small multiple! We specify the column metric in the by argument in tm_facets, which stores variables that the split will use. free.scales=T enables each facet (subplot) creates its own legend with its own scale. free.coords = F enables each map to have its own coordinate range, which is necessary if you have a multi-layer small multiple. You can specify the style of each facet in tm_layout with panel related arguments. In our example, we specify the name for each facet. tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_facets(by=&#39;metric&#39;, free.coords=F, free.scales = T) + tm_symbols(size=&quot;value&quot;, scale=1, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Measure of Power&#39;)) + tm_layout(panel.labels = c(&#39;Degree Centrality&#39;, &#39;Eigenvector Centrality&#39;, &#39;Betweenness Centrality&#39;, &#39;Clustering Coefficient&#39;)) From the maps above we can see that the most powerful mafia members are located around the New York City region. They are relatively more “powerful” in eigenvector centrality and betweenness centrality measures, and less so in degree centrality and clustering coefficients. Despite the concentration of power is in the Northeast, local mafia members can still be powerful as being well-embedded in a local social network. Many of the mafia families in the isolated regions (e.g., Colorado, Midwest, Texas) are very closely connected with each other. If you found the different value range across the metrics confusing or misleading (some metrics tend to follow power law), you can also standardize the metric values into respective percentile by adding the following lines before the gather. For example, a metric with value c(4, 1, 2, 3, 5) will be converted to c(0.75, 0, 0.25, 0.5, 1). MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) #Convert the metrics to percentile MafiaSpatial$degree = rank(degree(g))/length(degree(g)) MafiaSpatial$eigen = rank(eigen_centrality(g)$vector)/length(eigen_centrality(g)$vector) MafiaSpatial$betweenness = rank(betweenness(g, v=V(g)))/length(betweenness(g, v=V(g))) MafiaSpatial$cluster = rank(transitivity(g, type=&#39;local&#39;))/length(transitivity(g, type=&#39;local&#39;)) #same as above MafiaSpatial = MafiaSpatial %&gt;% gather(key=&#39;metric&#39;, value=&#39;value&#39;, degree:cluster) %&gt;% mutate(metric = factor(metric, levels=c(&#39;degree&#39;, &#39;eigen&#39;, &#39;betweenness&#39;, &#39;cluster&#39;))) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_facets(by=&#39;metric&#39;, free.coords=F, free.scales = T) + tm_symbols(size=&quot;value&quot;, scale=1, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Measure of Power&#39;)) + tm_layout(panel.labels = c(&#39;Degree Centrality&#39;, &#39;Eigenvector Centrality&#39;, &#39;Betweenness Centrality&#39;, &#39;Clustering Coefficient&#39;)) 5.3 Interactive Maps tmap allows users to view their maps in interactive modes with pre-defined Leaflet basemap styles, such as OpenStreetMap, Esri.WorldGrayCanvas, and Esri.WorldTopoMap. To view tmap object in interactive mode, set tmap_mode('view'). You also can change basemap styles through the layer widget in the RStudio Plots panel, or defined through tm_basemap() argument. This is a quick and easy way to generate preliminary maps with base maps for presentations and illustrations. The interactive mode can also help you examine your data in a spatial context by adding pop up labels or hover labels. MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) tmap_mode(&#39;view&#39;) tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) + tm_basemap(server = &quot;OpenTopoMap&quot;) You can also publish your tmap interactive map to web through RPub under your account. As an example, copy and paste the following code in a Rmd file. You can create Rmd file from Rstudio File-&gt;New File-&gt;R Markdown. In R Markdown, Knit the file and the option to Publish should appear. You can select the RPub option and create a free account. See this post for more details. At the moment, the interactive map from tmap did not have the function to adapt the node size with the zoom level. This function exists in Leaflet package with addCircleMarkers() function (more details see this tutorial) #### ---- Uncomment the commented lines below in R markdown ----- #### #--- #output: html_document #--- #```{r warning=FALSE, message=FALSE, echo=TRUE, eval=FALSE} library(tidyverse) library(sf) library(tmap) library(SSNtools) library(igraph) MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) #set tmap_mode to &#39;view&#39; will enable interactive mode in Rstudio Plots window tmap_mode(&#39;view&#39;) tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=5, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;), #determine the hover label id = &#39;NiceLabel&#39;, #determine the pop up contents popup.vars = c(&#39;Name: &#39;=&#39;NiceLabel&#39;, &#39;Mafia Family: &#39;=&#39;Family&#39;, &#39;Degree of Connections: &#39;=&#39;degree&#39;)) + #add a function where you can see coordinates on mouseover tm_mouse_coordinates() #``` This is an example publish to RPub and what the output will look like. Click and hover your mouse in the map to explore the pop up labels and see the changing coordinates on the top left corner. You can also switch the base map style in the box below the zoom functions. You may notice in the tmap interactive map above that when you zoom in, the node size did not change, which makes it difficult to exam areas with clustered nodes (e.g., New York City). For more advanced interactive map functions, we suggest users swtich to Leaflet, which is an open-source library for web-based interactive maps. The following codes generate an interactive map in R and allows users to see the name of the Mafia members when hover over the nodes. The node size dynamically adjusts when you zoom and out of the map. For ideas to reduce node cluttering in the static map, refer to Inset Map. library(leaflet) leaflet(MafiaSpatial) %&gt;% addTiles() %&gt;% addCircleMarkers(radius = ~ sqrt(degree), fillColor=&#39;#6698CC&#39;, fillOpacity = 0.8, label=~htmlEscape(NiceLabel)) 5.4 Base Map While interactive map comes with base maps, you can manually add base map into static maps in tmap. This section shows you how to use basemaps R package to add an Carto base map to tmap map in the plot mode. We use st_bbox to find the bounding box of U.S. states and use st_as_sfc() to transform it into a sfc object for retrieving stars object. Then we use the basemap_stars function in basemaps package to retrieve Mapbox base map based on the input bounding box information. basemaps support basemaps from OpenStreetMaps, Mapbox, Carto, and ESRI. Please refer to basemaps document for more examples on using other basemaps. The base map raster can be visualized by tmap through tm_rgb(). library(tigris) library(sf) library(tidyverse) library(basemaps) library(tmap) #states is a function in tigris to download U.S. state boundary shapefile us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) #Decide which basemap service to use and what map styles. set_defaults(map_service = &quot;carto&quot;, map_type = &quot;light&quot;) bgbox = st_bbox(us_states, crs=4326) %&gt;% st_as_sfc() bg = basemap_stars(bgbox) #process basemap into a raster ## Loading basemap &#39;light&#39; from map service &#39;carto&#39;... tmap_mode(&#39;plot&#39;) map = tm_shape(bg) + #add base map tm_rgb() + tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=1, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;)) map Here are all the available map_service and map_type: get_maptypes() ## $osm ## [1] &quot;streets&quot; &quot;streets_de&quot; &quot;streets_fr&quot; &quot;humanitarian&quot; &quot;topographic&quot; ## [6] &quot;hike&quot; &quot;hillshade&quot; &quot;grayscale&quot; &quot;no_labels&quot; &quot;mtb&quot; ## ## $osm_stamen ## [1] &quot;toner&quot; &quot;toner_bg&quot; &quot;toner_lite&quot; &quot;terrain&quot; &quot;terrain_bg&quot; ## [6] &quot;watercolor&quot; ## ## $osm_thunderforest ## [1] &quot;cycle&quot; &quot;transport&quot; &quot;landscape&quot; &quot;outdoors&quot; ## [5] &quot;transport_dark&quot; &quot;spinal&quot; &quot;pioneer&quot; &quot;mobile_atlas&quot; ## [9] &quot;neighbourhood&quot; &quot;atlas&quot; ## ## $carto ## [1] &quot;light&quot; &quot;light_no_labels&quot; &quot;light_only_labels&quot; ## [4] &quot;dark&quot; &quot;dark_no_labels&quot; &quot;dark_only_labels&quot; ## [7] &quot;voyager&quot; &quot;voyager_no_labels&quot; &quot;voyager_only_labels&quot; ## [10] &quot;voyager_labels_under&quot; ## ## $mapbox ## [1] &quot;streets&quot; &quot;outdoors&quot; &quot;light&quot; &quot;dark&quot; &quot;satellite&quot; &quot;hybrid&quot; ## [7] &quot;terrain&quot; ## ## $esri ## [1] &quot;natgeo_world_map&quot; ## [2] &quot;usa_topo_maps&quot; ## [3] &quot;world_imagery&quot; ## [4] &quot;world_physical_map&quot; ## [5] &quot;world_shaded_relief&quot; ## [6] &quot;world_street_map&quot; ## [7] &quot;world_terrain_base&quot; ## [8] &quot;world_topo_map&quot; ## [9] &quot;world_dark_gray_base&quot; ## [10] &quot;world_dark_gray_reference&quot; ## [11] &quot;world_light_gray_base&quot; ## [12] &quot;world_light_gray_reference&quot; ## [13] &quot;world_hillshade_dark&quot; ## [14] &quot;world_hillshade&quot; ## [15] &quot;world_ocean_base&quot; ## [16] &quot;world_ocean_reference&quot; ## [17] &quot;antarctic_imagery&quot; ## [18] &quot;arctic_imagery&quot; ## [19] &quot;arctic_ocean_base&quot; ## [20] &quot;arctic_ocean_reference&quot; ## [21] &quot;world_boundaries_and_places_alternate&quot; ## [22] &quot;world_boundaries_and_places&quot; ## [23] &quot;world_reference_overlay&quot; ## [24] &quot;world_transportation&quot; ## [25] &quot;delorme_world_base_map&quot; ## [26] &quot;world_navigation_charts&quot; Sometimes you may want a customized bounding box that is not based on data layer. A helpful tool to find the coordinates around your data is to visualize your data in the interactive mode with tm_mouse_coordinates() (see example above). You can also specify the bounding box of your base map using the following code: #remember to add crs argument for specialized coordinates box = st_bbox(c(xmin=-77.25586, xmax=41.82353, ymin=-71.10352, ymax=38.94553), crs=4326) %&gt;% st_as_sfc() 5.5 Inset Map From the current mafia member map we can see that a lot of the mafia members cluster around the New York City region. We are not able to see the details in that areas due to cluttered nodes. This is a common problem at mapping spatial social networks when you have a both regional and local social connections. To decide on the Inset Map bounding box, you can either use the measurement from other shapefiles (e.g., NYC five boroughs) or use tm_mouse_coordinates() (see example in Interactive Map) to identify ideal bounding box. The example below uses information picked up by the tm_mouse_coordinates(). First, we need to create the inset map. We pick a bounding box around the central New York City including where the most connected mafia member (in degree of connections) locates. We also calculate aspect_ratio for the inset map so that when plugged into the background map, we can preserve the inset map’s natural ratio of height and width. set_defaults(map_service = &quot;carto&quot;, map_type = &quot;light&quot;) # create the bounding box for the inset map and retrieve corresponding base map bgbox = st_bbox(c(xmin=-74.065141, xmax=-73.537727, ymin=40.558198, ymax=40.882353), crs=4326) inset_bg = basemap_stars(bgbox) # calculate aspect ratio. aspect_ratio = unname((bgbox$ymax - bgbox$ymin)/(bgbox$xmax - bgbox$xmin)) # putting base map as the first layer restricts the bounding box of the map, so no additional filtering for MafiaSpatial is needed. tmap_mode(&#39;plot&#39;) inset = tm_shape(inset_bg) + tm_rgb() + tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;), legend.size.show = FALSE) + tm_layout(main.title=&#39;Inset of New York&#39;, main.title.fontface = 2, main.title.position = c(&#39;center&#39;, &#39;top&#39;)) Then, we use tmap_save to export the background map map created in the Base Map section with the inset map. viewport function comes from the grid package and can be used to position the inset map on the background map. We set an arbitrary value for width and adjust the height according to the aspect ratio of the inset map to preserve its shape. You also can create multiple inset maps and pass to the insets_tm argument as a list (e.g., insets_tm = list(inset1, inset2)). Same for insets_vp. You can pass a list of viewport (e.g., insets_vp = list(viewport(X), viewport(Y))). #library(grid) tmap_save(map, insets_tm=inset, insets_vp = viewport(0.17, 0.75, width = 1, height = aspect_ratio*0.75), filename=&#39;PATH&#39;, dpi=600) We can also add a small black bounding box on the background map to indicate where the inset map locates. We also increase the line width of the frame of the inset map to visually match with the aesthetic of the bounding box. inset = inset + tm_layout(frame=TRUE, frame.lwd = 2) map = map + tm_shape(st_bbox(inset_bg) %&gt;% st_as_sfc()) + tm_polygons(alpha=0, border.col = &#39;black&#39;, lwd=2) tmap_save(map, insets_tm=inset, insets_vp = viewport(0.17, 0.75, width = 1, height = aspect_ratio*0.75), filename=&#39;PATH&#39;, dpi=600) 5.6 Edge Bundling Edge bundling is a technique to reduce visual cluttering of the edges. The algorithm behind edge bundling essentially bundles edges that go in the same direction and split them apart when they are close to their destinations. The algorithm of a complete edge bundling technique has three steps: first, it clusters edges based on their origin and destination; second, it calculates how to bend the geometry of a straight line given the user input of how “strong” you want the bundle to be. A stronger bundle means that you want more edges and edges far from the bundle to be bundled together; third, the algorithm may summarise the weights of the bundled edges so that the weight of the resultant bundle is larger (and thus visually thicker). You can implement edge bundling in QGIS2 or D3 or Python. This technique may help reveal structures in your edges when there are many lines, especially if you believe your edges follow a hierarchical structure, yet it is not a savior to your flow map. You should use this technique with caution because it has the following drawbacks: It takes a long time to do edge bundling. We recommend running our codes on a network with 1000-3000 edges to get quick feedback on the visual output. It may bend the edges in unnatural ways. It may be difficult to tell exactly where the edge come from and go to after you bend the edges. It may be difficult to visualize directionality in the flow map. You have to manually tune the parameters (thres in our case) to find the best visual outcome. There is no shortcut to find the optimized parameters at once. Some edge bundling package may only be able to bend the lines, but not summarise the edge weights. It means that it is difficult to visualize the edge weight of the bundle. The edgebundle package we used is still in development. We showed an example of applying the edgebundle package on the mafia map. To reduce the processing time, we filtered mafia connections to those that have more than 50km in euclidean distance, which results in 1668 edges. To filter by distance, we have to convert the coordinate system to North America Equidistant Conic (crs=102010), use st_distance to compute the distance between two point geometry, and lastly convert the meter object from st_distance into numeric numbers for filtering. It is important to note that you set by_element=TRUE in st_distance so that the output of the function is a vector rather than a matrix. The unit of the distance also follows the coordinate projection system you use. This is a mafia connectivity map without the edge bundling. #MafiaEdges and MafiaNodes is a built-in dataset of SSNtools package MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) #Filter MafiaEdges to edges that have more than 50km. FilteredEdges = MafiaEdges %&gt;% left_join(MafiaSpatial %&gt;% select(c(NODE, geometry)) %&gt;% st_transform(crs=102010), by = c(&#39;Source&#39; = &#39;NODE&#39;)) %&gt;% left_join(MafiaSpatial %&gt;% select(c(NODE, geometry)) %&gt;% st_transform(crs=102010), by = c(&#39;Target&#39; = &#39;NODE&#39;)) %&gt;% mutate(distance = st_distance(geometry.x, geometry.y, by_element=TRUE)) %&gt;% select(-c(geometry.x, geometry.y)) %&gt;% mutate(distance = as.numeric(distance)) %&gt;% filter(distance &gt; 50000) g = graph_from_data_frame(MafiaEdges, directed = FALSE) MafiaSpatial$degree = degree(g) #Convert FilteredEdges dataframe to line geometry. cnty_centroid = GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)) edges = od2line(ctc_commutes, cnty_centroid) EdgeSpatial = od2line(FilteredEdges, MafiaSpatial %&gt;% select(c(NODE, geometry))) tmap_mode(&#39;plot&#39;) map = tm_shape(bg) + tm_rgb() + tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(EdgeSpatial) + tm_lines(lwd=0.5, alpha=0.3, col=&#39;#1B665D&#39;) + tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;)) map The map shows clearly that many of the connections are going to New York City. There are also a lot of connections that go stragith from west coast to east coast. Let’s try edge bundling and see if it makes the map better. The edge_bundle_force function from the edgebundle pacakage takes into three arguments: 1) g which is the network constructed through igraph, 2) xy which is the longitude and latitude of all the nodes in the network, and 3) compatibility_threshold which indicates the strength of the bundling. A higher value means that the bending and the bundling will be less intense. This package can only bend the edges into bundles but not beyond that. The result of the edge_bundle_force returns four columns. x and y are the coordinates of the points that consist of a bundled edge. group indicates that coordinates in the same group are for one bundled edge and index indicates the order of points for that particular bundled edge. We can see that for group 1, the fbundle result starts with the first name in the Source of FilteredEdges, BLANDA-CHARLES (-104.6270, 38.2476), and after 34 points, it will end with the Target, SMALDONE-EUGENE (-104.9479, 39.7681). library(edgebundle) #FilteredEdges %&gt;% slice(1:3) # Source Target distance # 1 BLANDA-CHARLES SMALDONE-EUGENE 97252.56 # 2 DIVARCO-JOSEPH SICA-JOSEPH 6054967.18 # 3 DEMARTINO-BENJAMIN DEMARTINO-THEODORE 182989.39 #The current EdgeSpatial is line geometry bundle_g = graph_from_data_frame(FilteredEdges, directed=FALSE) node = data.frame(id = V(bundle_g)$name) %&gt;% mutate(id = as.character(id)) #&gt; id #&gt; 1 BLANDA-CHARLES #&gt; 2 DIVARCO-JOSEPH #&gt; 3 DEMARTINO-BENJAMIN node = node %&gt;% left_join(MafiaNodes %&gt;% select(c(NODE, LonX, LatY)), by=c(&#39;id&#39; = &#39;NODE&#39;), copy=FALSE) #&gt; id LonX LatY #&gt; 1 BLANDA-CHARLES -104.6270 38.2476 #&gt; 2 DIVARCO-JOSEPH -87.7354 42.0154 #&gt; 3 DEMARTINO-BENJAMIN -72.9263 40.9530 xy = cbind(node$LonX, node$LatY) fbundle = edge_bundle_force(bundle_g,xy,compatibility_threshold = 0.85) #&gt; x y index group #&gt; 1 -104.6270 38.24760 0.00000000 1 #&gt; 2 -104.6506 38.30726 0.03030303 1 #&gt; 3 -104.6641 38.33735 0.06060606 1 Thus, to create lines acceptable to tmap from the fbundle result, we need to convert coordinates to points, group by the group column, and summarise the points into lines. It is important that do_union=FALSE argument is set in the summarise() to preserve the order of points (otherwise summarise will rearrange the point order). fbundle2 = fbundle %&gt;% st_as_sf(coords=c(&#39;x&#39;, &#39;y&#39;), crs=4326) %&gt;% group_by(group) %&gt;% summarise(do_union=FALSE) %&gt;% st_cast(&quot;LINESTRING&quot;) #&gt; group geometry #&gt; &lt;dbl&gt; &lt;LINESTRING [°]&gt; #&gt; 1 1 (-104.627 38.2476, -104.6506 38.30726, -104.6641 38.33735...) #&gt; 2 2 (-87.7354 42.0154, -88.8135 41.62707, -89.64513 41.35496 ...) #&gt; 3 3 (-72.9263 40.953, -72.95451 40.95169, -72.98361 40.94916 ...) Now the fbundle2 is a line shapefile! We can either export to GIS for further editing or map it using tmap package. See Base Map on how to create bg background base map and us_states boundary shapefiles. tmap_mode(&#39;plot&#39;) tm_shape(bg) + tm_rgb() + tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(fbundle2) + tm_lines(lwd=0.5, alpha=0.3, col=&#39;#1B665D&#39;) + tm_shape(MafiaSpatial %&gt;% arrange(desc(degree))) + tm_symbols(size=&quot;degree&quot;, scale=2, col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;)) The bundling effect is most obvious when you contrast lines going from Florida to New York. Several edges have been bundled together. However, you can also see some unnatural bends from lines going from Florida to New York City. That is because the lines were bended halfway. In our case of the mafia map, we are not sure the edge bundling improves the visual. Again, edge bundling should be applied with cautions and experiments. "],["advanced-ssn-metrics.html", "Chapter 6 Advanced SSN Metrics 6.1 SSN Hotspots Detection 6.2 K-fullfillment 6.3 Flattening Ratio 6.4 Linked Activity Spaces", " Chapter 6 Advanced SSN Metrics The following subchapters will introduce advanced SSN metrics. Spatial Social Network (SSN) refers to social networks where the nodes are also geolocated. They can be collaborations between organizations, economic hiring between individuals, trades between companies, and friendships. Different from social network metrics or spatial methods, these metrics tend to focus on the interaction between the networks and geographic space. While the metrics are designed for small-scale SSNs, some can also be applied to analyze origin-destination flows, POI visits, and mobility data. 6.1 SSN Hotspots Detection In this chapter we show two GIS methods, EdgeScan and NDScan, for capturing areas with high and low levels of number of edges or network density respectively. Both methods are moving window processes that count the number of edges and network density, respectively, for each node in a given focal area (window area). It is important to note that while our functions report EdgeScan and NDScan values on the node level, these values represent local social connections in the moving window area centered by that node. Thus, it is possible that a node can have high EdgeScan and NDScan values, but are not connected with others locally. The contents below come from this paper published in Transactions in GIS: Is Your Neighbor Your Friend? Scan Methods for Spatial Social Network (SSN) Hotspot Detection (Liang et al., 2023). Here are some example research questions that will benefit from EdgeScan and NDScan metrics: (Mafia members SSN) Where do mafia members both cluster in geographic proximity and connect in network space? (Restaurant POI visits SSN) Where do restaurants cluster and serve local clientele (i.e., heavy-weighted connections to nearby census block groups)? (Food sharing SSN) Where are organizations that locate close-by but do not collaborate or share resources with each other? Our tutorial will cover the following topics: How to calculate SSN hotspots using edgeScanRadius(), edgeScanManhattan(), edgeScanKNearest(), NDScanRadius(), NDScanManhattan, and NDScanKNearest() in SSNtools. How to visualize SSN hotspots (Advanced) How to find optimal window sizes for SSN hotspots (Advanced) How to calculate SSN hotspots within a walking distance radius, using NDScanMatrix() and edgeScanMatrix() in SSNtools, with OSM (OpenStreetMap) data as an input matrix. (Advanced) Application to a weighted and bipartite network (POI visits) To begin, let us introduce the basic ideas behind the EdgeScan and NDScan methods. Both methods are based on spatial scan approaches, which summarised statistics in a moving window for a focal node. Therefore, for each node in the network, EdgeScan and NDScan calculate the number of edges and network density in the area centered by the focal node. Network density is the ratio of actual number of edges and the potential number of edges. A high network density (=1) means that nodes in the moving window have maximize all the possible combinations of connections. Our EdgeScan and NDScan methods provide four different neighborhood definitions: Euclidean distance Manhattan distance User-defined distance (e.g., walking distance) K-nearest neighbors The users can input the following window size distance in the unit of coordinate systems (meter in our example) a user-defined distance matrix the number of nearest neighbors. The graphic below shows a schematic diagram of how the EdgeScan and NDScan value for a focal node is calculated. The window in the first circle simultaneously represents a potential window size of Euclidean distance of 400m, Manhattan distance of 500m, and 7-nearest neighbors. Figure 6.1: Schematic Diagram of EdgeScan and NDScan Values Calculation We will continue to use sample datasets NYCMafiaNodes, NYCMafiaEdges, POINodes, and POIEdges and in SSNtools to illustrate examples. To load the sample datasets and the functions, go to GitHub SSNtool to download the development R package, or type the following lines in your R console. Click the GitHub page for more detailed description of all the functions available in the package and the input formats for each function. # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) NYCMafiaNodes is a node table with label and spatial coordinates for each node (a mafia member). NYCMafiaeEdges contains pairs of node labels (corresponding to node table label), representing mafia criminal associations. This is a unweighted and undirected network. The coordinate system crs is 32118, in the unit of meters. Data in POINodes and POIEdges are processed from SafeGraph with extra filters and coding to hide sensitive information. The dataset is meant to be educational and thus can be inaccurate for real implications. The nodes in the dataset are restaurants in Atlanta (set 0) and centroids of census block group (set 1). The edges in the dataset are visits from the census block group to restaurants. The weight of the edges represent the percentage of total visits coming from a particular census block group. You can call POINodes (n=1356) and POIEdges (n=7926) to directly access the sample dataset. The coordinates system is transformed with crs=26967 (unit meter). Functions in SSNtools run on base R syntax, though wrangling data may require additional package dependencies. Based on the definitions of EdgeScan and NDScan, directed argument is only implemented for ND-functions, while weighted argument is only implemented for the Edge-functions. 6.1.1 Calculate SSN hotspots using radius or K-nearest neighbor window sizes To get EdgeScan and NDScan value for each node, you just need to run your node and edge tables through the following codes: library(SSNtools) data(NYCMafiaNodes) data(NYCMafiaEdges) # ----process dataframe into a list of lists # params: # data - a R dataframe containing node label, longitude, and latitude # label_name - the name of the column for node label # lon_name - the name of the column for node longitude # lat_name - the name of the column for node latitude # bipartite_name - (optional) the name of the column that indicates the bipartite set of the nodes. The set of nodes that EdgeScan or NDScan should report on should be coded as 1 in the biparite column, and 0 otherwise. nodes = processNode(NYCMafiaNodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;) # params: # data - a R dataframe containing source node label and target node label # source_name - the name of the column for source node label # target_name - the name of the column for target node label # weight_name - (optional) the name of the column for edge weight edges = processEdge(NYCMafiaEdges, &#39;Source&#39;, &#39;Target&#39;) #----calculate the density of edges within a radius (500 meters - Euclidean distance) of every node in a graph # params: # nodes - a list of named lists. Each sublist contains a node. # edges - a list of list. Each sublist contains an edge. # radius - radius (in the coordinate unit) of the scanning window. # (optional) min - minimum number of points required to be in the search window. Default to 3. # (optional) weighted - whether the result, number of edges, will be weighted (as sum of edge weights). Default to FALSE. # (optional) bipartite - whether the result will be calculated as a bipartite network. Default to FALSE. # return: # list(heat, edgeWithin) - a list of two dataframe for node and edge table. result = edgeScanRadius(nodes, edges, 500) heat = result[[1]] edgeWithin = result[[2]] #-----calculates network density within a radius (500 meters - Euclidean distance) of each node in a network # params: # nodes - a list of named lists. Each sublist contains a node. # edges - a list of list. Each sublist contains an edge. # radius - radius (in the coordinate unit) of the scanning window. # (optional) min - minimum number of points required to be in the search window. Default to 3. # (optional) directed - whether the result, network density, will be calculated as a directed network. Default to FALSE. # (optional) bipartite - whether the results will be calculated as a bipartite network. Default to FALSE. # return: # list(heat, edgeWithin) - a list of two dataframe for node and edge table. result = NDScanRadius(nodes, edges, 500) heat = result[[1]] edgeWithin = result[[2]] Interpret Outputs All the SSNhotspot main functions (e.g, edgeScanRadius and NDScanRadius) will return a list of two dataframes. The first dataframe is a node table wtih two columns: label: the node label heat: the number of edges in EdgeScan and network density in NDScan respectively. The second dataframe is an edge table that has three columns: Source: source node label Target: target node label WithinWindow: binary value (1 or 0) indicating whether the edge is within the scanning window. Below are example outputs of the heat and edgeWithin dataframes. If the nodes (e.g., AMAROSA-ALEXANDER) do not meet the min argument requirement (in this case, min=3 and thus three nodes in the moving window), the heat value will be NA. Zero has practical meaning in the outputs: it means that there are no connections within the center node’s searching window despite having at least three nodes. #----- print example NDSCanRadius outputs at selected rows ------ heat[c(1,93,102), ] ## label heat ## 1 AMAROSA-ALEXANDER NA ## 93 SIANO-FIORE 0.0 ## 102 POLIZZANO-RALPH 0.6 edgeWithin[c(1,254,259), ] ## Source Target WithinWindow ## 1 SALERNO-ANTHONY ALBERO-CHARLES 0 ## 254 SIANO-FIORE PAGANO-PASQUALE 0 ## 259 POLIZZANO-RALPH DIPALERMO-CHARLES 1 Here are other SSN hotspots functions using various window size definitions. The parameters are the same as edgeScanRadius() and NDScanRadius(). #-----calculates network density within 10 nearest neighbors of each node in a network heat = NDScanKNearest(nodes, edges, 10)[[1]] #-----calculates network density within a radius (500 meters - Manhattan distance) of each node in a network heat = NDScanManhattan(nodes, edges, 500)[[1]] #-----calculates the density of edges within 10 nearest neighbors of each node in a network heat = edgeScanKNearest(nodes, edges, 10)[[1]] #-----calculates the density of edges within a radius (500 meters - Manhattan distance) of each node in a network heat = edgeScanManhattan(nodes, edges, 500)[[1]] 6.1.2 Visualize SSN hotspots To visualize SSN hotspots, we need to attach spatial information to nodes in the heat dataframe and visualize nodes based on the hotspot values (i.e., column heat). If the codes below are foreign to you, review Chapter 5: Advanced Aesthetics for more details. library(tmap) library(basemaps) library(sf) library(tidyverse) library(stplanr) library(SSNtools) # we will use NDScanRadius as an example result = NDScanRadius(nodes, edges, 500, min=3) heat = result[[1]] edgeWithin = result[[2]] # convert heat dataframe to a spatial sf object MafiaSpatial = heat %&gt;% left_join(NYCMafiaNodes, by=c(&#39;label&#39;), copy=FALSE) %&gt;% st_as_sf(coords=c(&#39;LonX&#39;, &#39;LatY&#39;), crs=32118) # convert edgeWithin dataframe to line geometry and filter those that are within the window radius. NYCMafiaEdges_shp = od2line(edgeWithin, MafiaSpatial) %&gt;% filter(WithinWindow == 1) # create basemap with functions from basemaps library set_defaults(map_service = &quot;carto&quot;, map_type = &quot;light&quot;) bgbox = st_bbox(MafiaSpatial) %&gt;% st_as_sfc() bg = basemap_stars(bgbox) ## Loading basemap &#39;light&#39; from map service &#39;carto&#39;... # create hotspot map with functions from tmap library tmap_mode(&#39;plot&#39;) g = tm_shape(bg) + tm_rgb(alpha=0.8) + #map edges within searching window tm_shape(NYCMafiaEdges_shp) + tm_lines(col=&#39;black&#39;, lwd=1) + #map nodes with NA values tm_shape(MafiaSpatial %&gt;% filter(is.na(heat))) + tm_symbols(col=&#39;white&#39;, size=0.05) + #map nodes with heat values, allowing nodes with higher heat values to be mapped on top tm_shape(MafiaSpatial %&gt;% drop_na(heat) %&gt;% arrange(heat)) + tm_symbols(col=&#39;heat&#39;, size=0.1, style=&#39;fixed&#39;, legend.col.show = FALSE, palette = c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;), breaks=c(0, 0.00001, 0.10, 0.25, 0.667)) + #customize legend and layout tm_add_legend(type=&#39;symbol&#39;, labels=c(&#39;0&#39;, &#39;(0, 0.10]&#39;, &#39;(0.10, 0.25]&#39;, &#39;(0.25, 0.667]&#39;, &#39;NA (Less than MinPts)&#39;), col=c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;, &#39;white&#39;), is.portrait = T, title=c(&#39;Network Density&#39;), size=0.5) + tm_add_legend(type=&#39;line&#39;, labels=c(paste0(&#39;Edges within window size&#39;)), col=&#39;black&#39;, lwd=1) + tm_scale_bar(breaks=c(0, 5, 10), text.size = 0.7) + tm_layout(legend.title.size = 0.9, legend.text.size = 0.7, legend.width = 1) + tm_layout(main.title = &#39;NYC 1960s Mafia SSN Hotspots&#39;, main.title.position = c(&#39;center&#39;), main.title.size = 1.5) g You may wonder why edges are invisible: that is because the edges within the window size (500m) are short-ranged and thus may be hidden under the nodes! The following codes add an inset map to highlight an area with dense SSN hotspots. # create a bounding box in crs=32118 to retrieve basemap Inset = st_bbox(data.frame(lon=c(-74.00434, -73.98125), lat=c(40.73080, 40.71109)) %&gt;% st_as_sf(coords=c(&#39;lon&#39;, &#39;lat&#39;), crs=4326) %&gt;% st_transform(crs=32118)) # create a basemap for the inset map Inset_bg = basemap_stars(Inset) # create the inset map InsetMap = tm_shape(Inset_bg) + tm_rgb() + tm_shape(NYCMafiaEdges_shp ) + tm_lines(col=&#39;black&#39;, lwd=1) + tm_shape(MafiaSpatial %&gt;% filter(is.na(heat))) + tm_symbols(col=&#39;white&#39;, size=0.05) + tm_shape(MafiaSpatial %&gt;% drop_na(heat) %&gt;% arrange(heat)) + tm_symbols(col=&#39;heat&#39;, size=0.2, style=&#39;fixed&#39;, breaks=c(0, 0.00001, 0.10, 0.25, 0.667), legend.col.show = FALSE, palette = c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;)) + tm_layout(frame=c(&#39;black&#39;), frame.lwd = 2, main.title = c(&#39;Little Italy&#39;), main.title.position = c(&#39;center&#39;), main.title.size = 0.8, fontface = 2) # create the bounding box map box = tm_shape(st_bbox(Inset) %&gt;% st_as_sfc()) + tm_polygons(alpha=0, border.col=&#39;black&#39;, lwd=1) # create aspect ratio to preserve the height and width ratio in the inset map aspect_ratio = unname((Inset$ymax - Inset$ymin)/(Inset$xmax - Inset$xmin)) # export the background map g with the inset map. library(grid) tmap_save(g + box, insets_tm=InsetMap, insets_vp = viewport(0.21, 0.54, width = 0.3, height = aspect_ratio*0.5), filename=&#39;PATH&#39;, dpi=600) 6.1.3 Find optimal window sizes for SSN hotspots SSN hotspots are sensitive to neighborhood definition and window sizes. Neighborhood definition should match theoretical questions, such as: Is distance between nodes meaningful; is travel time a factor in the study; or do events form natural clusters of varying radii? As such, there may not be an optimal window size, but visualizing outputs can help with decisions. Here, we shows how to create a graphic reporting the sensitivity of NDScan results (y values) by window sizes (x values) at the DBSCAN (Density-based Spatial Clustering of Applications with Noise) cluster level. We are interested to see how the average values of EdgeScan and NDScan vary for each SSN hotspots cluster, wherein consistent y values across the x axis would signal a robust method that is not sensitive to change in window size. Conceptually, the codes below are doing the following: create an empty dataframe with three columns cluster, Average Network Density, and Window Size. loop through the window sizes and at each window size, do the following operation: attach spatial information to the NDScanRadius() output assign the DBSCAN cluster ID back to each node calculate the average network density by DBSCAN cluster ID visualize average NDScan values (i.e., average network density) for each DBSCAN cluster at each window size through a raincloud plot library(SSNtools) library(ggplot2) library(ggdist) library(fpc) nodes = processNode(NYCMafiaNodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;) edges = processEdge(NYCMafiaEdges, &#39;Source&#39;, &#39;Target&#39;) # create an empty dataframe to store values in the loop df = data.frame(matrix(ncol = 3, nrow = 0)) colnames(df) = c(&#39;cluster&#39;, &#39;Average Network Density&#39;, &#39;Window Size&#39;) # loop through each window size (meter) for (i in seq(100, 2000, 100)) { # calculate the heat values heat = NDScanRadius(nodes, edges, i, min=3)[[1]] # attach spatial information to nodes whose heat is not NA MafiaSpatial = heat %&gt;% drop_na(heat) %&gt;% left_join(NYCMafiaNodes, by=c(&#39;label&#39;), copy=FALSE) # assign the DBSCAN cluster ID back to each node; # DBSCAN eps argument takes in the same reachability distance value (window size) and reachability minimum no. of points as the NDScanRadius() MafiaSpatial$cluster = fpc::dbscan(MafiaSpatial %&gt;% select(c(LonX, LatY)), eps = i, MinPts = 3)$cluster # filter noise (fpc::dbscan classified noise into cluster 0) and calculate the average network density by DBSCAN cluster MafiaSpatial = MafiaSpatial %&gt;% filter(cluster != 0) %&gt;% group_by(cluster) %&gt;% summarise(`Average Network Density`=mean(heat)) %&gt;% mutate(`Window Size` = i) # merge output from one window size into the final dataframe df = rbind(df, MafiaSpatial) } # visualize through a raincloud plot g = ggplot(df, aes(x=`Window Size`, y=`Average Network Density`, group=`Window Size`)) + geom_boxplot(colour = &quot;lightgrey&quot;, outlier.color = NA, width=0.2) + ggdist::stat_dots(side=&#39;left&#39;, justification=1.1, binwidth=0.01, alpha=0.5, col=&#39;black&#39;, dotsize=1) + ylab(&#39;Avg. Network Density per DBSCAN Cluster&#39;) + xlab(&#39;Window Size (Euclidean Distance Meter)&#39;) + ggtitle(paste0(&#39;New York Optimal Window Size for NDScan&#39;)) + theme_classic() + theme(plot.title = element_text(hjust = 0.5, size=20), legend.text = element_text(size=15)) # manually added reference lines on g Interpret Outputs The graphic above highlights three interesting distance ranges for optimal window sizes. At a window size of 100-200 m, there is a fully connected cluster of Mafia members (labeled with arrow c). From 400-2000 m, a cluster is consistent with the network density of 0.67 despite the increasing window size, suggesting that the cluster is either spatially isolated from other Mafia members or any additional Mafia member within the increased scanning window is fully connected to existing cluster members (labeled with arrow d). From 500m-1.3 km, there are four to five medium-high density clusters that are stable across window sizes (labeled with arrow e). Therefore, these ranges may be optimal to reveal interesting or robust outcomes. 6.1.4 Calculate SSN hotspots using a user-defined walking distance matrix extracted from OSM Euclidean and Manhattan are theoretical distances between two nodes, but in reality, travel distance (e.g., walking distance) can be mediated by geographic features. edgeScanMatrix and NDScanMatrix function take in: nodes, a list of named lists. Each sublist contains a node. edges, a list of list. Each sublist contains an edge. matrix, a full distance matrix (i.e., the column and row includes all nodes) ** with column and row names ** with symmetrical cell values being travel distance between OD ** with the diagonal pairs (self pairs) coded with NA. When calculating the number of nodes within the window size (e.g., the first row for A1), cells with NA are automatically excluded. 0 represents zero distance. (optional) min, minimum number of points required to be in the search window. Default to 3. (optional) bipartite, TRUE or FALSE. If TRUE, bipartite column name should be identified in the processNode(). (optional) weighted, TRUE or FALSE. If TRUE, weight column name should be identified in the processEdge(). Below is an example of a full distance matrix with nodes A1, A2, A3: # A1 A2 A3 # A1 NA 0 1 # A2 0 NA 2 # A3 1 2 NA This input format is also required for bipartite networks, even for nodes within the same set. For example, in a bipartite network, if you have 4 nodes and they are A1, A2, B1, B2, then your distance matrix should be 4 by 4 and self-pairs are coded as NA (see below). It is important to note that even though B1B2 (or B2B1) has no connections, they should still have a distance value (=3) in the distance matrix. This is because number of edges and network density needs to know all the nodes within the distance threshold. # A1 A2 B1 B2 # A1 NA 0 1 2 # A2 0 NA 1 2 # B1 1 1 NA 3 # B2 2 2 3 NA To pull actual travel distance between OD pairs, we recommend using osrm package in R. ORSM is a routing service based on OpenStreetMap data, which allows travel distance calculated in walking, biking, or driving modes. We are most interested in its ability to calculate many-to-many routing distance quickly through osrmTable() function. Please read the osrm documentation carefully if you are applying it to a large amount of data, as it discourages heavy usage. Let’s say our goal is to get EdgeScan or NDScan values for NYCMafiaNodes and NYCMafiaEdges within a 1 mile walking distance (~1600m), using a osrm generated walking distance matrix. Here are the steps: create a dataframe that contains all non-repetitive combinations of nodes (nrow = 44253). Our functions require this information to decide the number of nodes within the window size threshold (and calculate network density), even if the nodes are not connected. (optional) filter the dataframe to OD pairs within 2000 meters Euclidean distance to reduce workload for routing calculation. create a origin and destination table where each row is a node with coordinates. use osrmTable to calculate many-to-many routing distance for a subset of data (so that it does not overtax the osrm server, such as 99 rows). Iterate this process until all data are calculated. transform the OD dataframe to the input matrix format for edgeScanMatrix and NDScanMatrix functions. Step 1-3 are coded as the following: library(tidyverse) # create a dataframe that contains all non-repetitive combinations of nodes allEdgesTable = as.data.frame(t(combn(NYCMafiaNodes$label, 2))) colnames(allEdgesTable) &lt;- c(&#39;Source&#39;, &#39;Target&#39;) edgeDistance = allEdgesTable %&gt;% #attach coordinates to allEdgesTable left_join(NYCMafiaNodes, by=c(&#39;Source&#39; = &#39;label&#39;), copy=FALSE) %&gt;% left_join(NYCMafiaNodes, by=c(&#39;Target&#39; = &#39;label&#39;), copy=FALSE) %&gt;% #calculate Euclidean distance (again, the unit is meter) mutate(dist = sqrt((LonX.x - LonX.y) ** 2 - (LatY.x - LatY.y)**2)) %&gt;% filter(dist &lt;= 2000) # print example outputs edgeDistance[c(1:3), ] ## Source Target LonX.x LatY.x LonX.y LatY.y ## 1 AMAROSA-ALEXANDER BIONDO-JOSEPH 302206.2 57958.61 309374.0 64916.18 ## 2 AMAROSA-ALEXANDER MANNARINO-GIACINTO 302206.2 57958.61 303457.1 58580.96 ## 3 AMAROSA-ALEXANDER CARRUBBA-CORRADO 302206.2 57958.61 300557.9 56947.99 ## dist ## 1 1723.116 ## 2 1085.023 ## 3 1302.158 # create origin and destination table origin = edgeDistance %&gt;% select(c(Source, LonX.x, LatY.x)) %&gt;% st_as_sf(coords=c(&#39;LonX.x&#39;, &#39;LatY.x&#39;), crs=32118) %&gt;% #osrmTable() assumes inputs are in crs=4326 st_transform(crs=4326) %&gt;% mutate(LonX = sf::st_coordinates(.)[,1], LatY = sf::st_coordinates(.)[,2]) %&gt;% st_drop_geometry() des = edgeDistance %&gt;% select(c(Target, LonX.y, LatY.y)) %&gt;% st_as_sf(coords=c(&#39;LonX.y&#39;, &#39;LatY.y&#39;), crs=32118) %&gt;% #osrmTable() assumes inputs are in crs=4326 st_transform(crs=4326) %&gt;% mutate(LonX = sf::st_coordinates(.)[,1], LatY = sf::st_coordinates(.)[,2]) %&gt;% st_drop_geometry() # print example outputs origin[c(1:3), ] ## Source LonX LatY ## 1 AMAROSA-ALEXANDER -73.9739 40.6886 ## 2 AMAROSA-ALEXANDER -73.9739 40.6886 ## 3 AMAROSA-ALEXANDER -73.9739 40.6886 For step 4, to avoid overtaxing the osrm backend, the following codes only show how to extract walking distance for the first 10 rows of data in origin and des dataframe. Note that osrmTable() assumes coordinate system crs to be 4326 and return distance in the unit of meters. origin_sub = origin[c(1:10),] des_sub = des[c(1:10),] library(osrm) # distances contains a list of outputs. distances &lt;- osrmTable( src = origin_sub[c(&quot;LonX&quot;, &quot;LatY&quot;)], dst = des_sub[c(&quot;LonX&quot;, &quot;LatY&quot;)], osrm.profile = &quot;foot&quot;, measure = c(&quot;distance&quot;) ) # distances$distances returns a full distance matrix between all nodes in origin_sub and des_sub. We are only interested in the pairwise result and thus only take the diagonal values. Distance values are meters. Distance_m = diag(distances$distances) Distance_m ## 1 2 3 4 5 6 7 8 9 10 ## 11868 1815 2521 1220 5584 8237 941 1027 1027 4332 # if you are running the sample codes above in loop, force the system to sleep 1s before running the next loop # Sys.sleep(1) For step 5, we assume readers have acquired walking distance values for all rows of data. Here we filled the Distance_m vector with random values to demonstrate the codes. # fill Distance_m with random values Distance_m = sample.int(2000, nrow(origin), replace=TRUE) dist = data.frame(Source = origin$Source, Target = des$Target, Distance_m = Distance_m) # create an edge table with walking distance edgeDistance = edgeDistance %&gt;% left_join(dist, by=c(&#39;Source&#39;, &#39;Target&#39;), copy=FALSE) %&gt;% select(c(Source, Target, Distance_m)) %&gt;% mutate(Distance_m = ifelse(Distance_m == 0, 0.001, Distance_m)) library(igraph) # create input full matrix from the edge table. # as_adjacency_matrix() fills empty sell with zeros. # zero has practical meaning in our example. # Thus we convert 0 to NA # and converted those that have actual 0 in distance (converted to 0.001 in the code above) back to 0. g = graph_from_data_frame(edgeDistance, directed=FALSE, vertices=NYCMafiaNodes) mat = as_adjacency_matrix(g, sparse=F, attr=&quot;Distance_m&quot;) mat[mat==0]&lt;-NA mat[mat==0.001]&lt;-0 # find SSN hotspots within 1 mile (~1600m) walking distance! nodes = processNode(NYCMafiaNodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;) edges = processEdge(NYCMafiaEdges, &#39;Source&#39;, &#39;Target&#39;) result = edgeScanMatrix(nodes, edges, 1600, mat, min=3) heat = result[[1]] edgeWithin = result[[2]] heat[c(1:3),] ## label heat ## 1 AMAROSA-ALEXANDER NA ## 2 VINTALORO-JAMES NA ## 3 TANTILLO-ENRICO NA edgeWithin[c(1:3),] ## Source Target WithinWindow ## 1 SALERNO-ANTHONY ALBERO-CHARLES 0 ## 2 CARUSO-FRANK NOBILE-GEORGE 0 ## 3 LISI-GAETANO MARI-FRANK 1 6.1.5 Application to a weighted and bipartite network We have applied the EdgeScan and NDScan functions to NYCMafiaNodes and NYCMafiaEdges, which is an unweighted, undirected, and non-bipartite network. We can apply the same functions to a weighted and/or bipartite network, using sample dataset POINodes and POIEdges in SSNtools. If you are using your own dataset, there should be a bipartite column that indicates which set the node is in. The set that would like have EdgeScan or NDScan values reported should be coded as 1, and 0 otherwise. In our POINodes sample dataset, restaurant POIs are coded as 1 and census block group centroids are coded as 0 in the bipartite network. Please reference the sample dataset if you are unclear of the input formats. We chose K-nearest neighbor as the neighborhood definition for analyzing the sample dataset and KNN=5 as the window size. Here, the distance between the POI (restaurant) and census block group centroids vary across geographic space, because the size of the census block groups tend to be smaller in the city center than the suburbs. Thus, a KNN neighborhood definition is better because it searches for the five closest census block groups (CBGs) around the POI, ignoring distances between the two. library(SSNtools) data(POINodes) data(POIEdges) nodes = processNode(POINodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;, &#39;Bipartite&#39;) edges = processEdge(POIEdges, &#39;Source&#39;, &#39;Target&#39;, &#39;Weight&#39;) The following codes use edgeScanKnearest(): # calculate edgeScan values for KNN = 5 in a weighted, bipartite network # this takes about 3 mins to run result = edgeScanKNearest(nodes, edges, 5, weighted=TRUE, bipartite=TRUE) heat = result[[1]] edgeWithin = result[[2]] heat[c(1:3),] # label heat # 1 poi1 476.2827 # 2 poi2 1250.8860 # 3 poi3 1160.1423 edgeWithin[c(1:3),] # Source Target Weight WithinWindow # 1 poi1 130890204001 14.545455 1 # 2 poi1 130890205002 7.272727 0 # 3 poi1 131210001002 7.272727 0 The following codes use NDScanKnearest(): # calculate NDScan values for KNN = 5 in an undirected, bipartite network # this takes about 3 mins to run result = NDScanKNearest(nodes, edges, 5, directed=FALSE, bipartite=TRUE) heat = result[[1]] edgeWithin = result[[2]] heat[c(1:3),] # label heat # 1 poi1 0.2758621 # 2 poi2 0.2254428 # 3 poi3 0.3029557 edgeWithin[c(1:3),] # Source Target WithinWindow # 1 poi1 130890204001 1 # 2 poi1 130890205002 0 # 3 poi1 131210001002 0 Interpret Outputs Note that when the network is weighted, edgeScan related functions report the sum of edge weights instead of the number of edges. If the network is bipartite, only nodes whose bipartite value is coded as 1 (in this case, POI) will report values. The formula to calculate network density also changes if a network is bipartite (see Figure: Schematic Diagram of EdgeScan and NDScan Values Calculation above). Based on the definitions of EdgeScan and NDScan, directed argument is only implemented for ND-functions, while weighted is only implemented for the Edge-functions. To visualize the POI visits hotspots, you can use the following codes as a reference. library(tmap) library(tidyverse) library(basemaps) library(sf) # convert heat dataframe to a spatial sf object POISpatial = heat %&gt;% left_join(POINodes, copy=FALSE) %&gt;% st_as_sf(coords=c(&#39;LonX&#39;, &#39;LatY&#39;), crs=26967) # attach spatial information to edgeWithin and convert edgeWithin dataframe to line geometry edgeWithin = edgeWithin %&gt;% left_join(POINodes, by=c(&#39;Source&#39; = &#39;label&#39;), copy=FALSE) %&gt;% left_join(POINodes, by=c(&#39;Target&#39; = &#39;label&#39;), copy=FALSE) # convert points to lines without stplanar package. See Chapter 4.1.3. st_segment = function(r){st_linestring(t(matrix(unlist(r), 2, 2)))} edgeWithin$geometry = st_sfc( sapply(1:nrow(edgeWithin), function(i){st_segment(edgeWithin[i,][c(&#39;LonX.x&#39;, &#39;LatY.x&#39;, &#39;LonX.y&#39;, &#39;LatY.y&#39;)])}, simplify=FALSE)) # convert edgeWithin back to sf object and filter edges to be within the window edgeWithin = edgeWithin %&gt;% st_as_sf() %&gt;% st_set_crs(26967) %&gt;% filter(WithinWindow == 1) # create basemap set_defaults(map_service = &quot;carto&quot;, map_type = &quot;light&quot;) bgbox = st_bbox(POISpatial) bg = basemap_stars(bgbox, map_service = &#39;carto&#39;) # parameters for visualization legend_name = &#39;Network Density&#39; k = &#39;5&#39; breaks = c(0.07, 0.30, 0.40, 0.50, 1) labels = c(&#39;[0.07, 0.30)&#39;, &#39;[0.3, 0.4)&#39;, &#39;[0.4, 0.50)&#39;, &#39;[0.50, 0.75]&#39;) output = c(&#39;Atlanta POI Visits NDScan&#39;) # visualize the SSN hotspots tmap_mode(&#39;plot&#39;) g = tm_shape(bg) + tm_rgb(alpha=0.8) + tm_shape(edgeWithin) + tm_lines(alpha=0.5) + tm_shape(POISpatial) + tm_symbols(col=&#39;heat&#39;, size=0.05, style=&#39;fixed&#39;, legend.col.show = FALSE, palette = c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;), breaks=breaks) + tm_add_legend(type=&#39;symbol&#39;, labels=labels, col=c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;), title=paste0(legend_name, &#39; (KNN = &#39;, k, &#39;)&#39;), size=0.5) + tm_add_legend(type=&#39;line&#39;, labels=c(paste0(&#39;Edges within window size&#39;)), col=&#39;black&#39;, lwd=1) + tm_scale_bar(breaks=c(0, 1, 2, 4), text.size = 1) + tm_layout(legend.title.size = 1.3, legend.text.size = 1, legend.width = 1) + tm_layout(legend.bg.color = &#39;white&#39;, legend.bg.alpha = 0.7, main.title = output, main.title.position = c(&#39;center&#39;)) 6.2 K-fullfillment K-fullfillment is a node-level metric to describe local (dis)connection. It is defined as the percentage of a node’s K-nearest neighbors (in Euclidean space) that it is connected (i.e., connected K-nearest neighbors divided by total K-nearest neighbors). Here, K is equal to the node’s degree. Nodes that are exclusively connected to their nearest neighbors will have a K-fulfillment value of 1. K-fullfillment assumes that the target SSN is an unweighted, undirected network. Here are some example research questions that can be answered by the K-fullfillment metric: (Mafia members SSN) Which mafia members have strong local connections (i.e., higher percentage of K-nearest neighbors connected)? (Restaurant POI visits SSN) Which restaurant tends to serve residents from nearby census block groups? (Food sharing SSN) Which organization is highly connected to other local organizations? Our tutorial will cover the following topics: How to calculate K-fullfillment values on the node level using Kfullfillment() in SSNtools. How to visualize K-fullfillment values on the node level and connections to the nearest neighbors. We will continue to use sample dataset NYCMafiaNodes, NYCMafiaEdges, POINodes, and POIEdges in SSNtools to illustrate examples. To load the sample dataset and the functions, go to GitHub SSNtool to download the development R package, or type the following lines in your R console. Click the GitHub page for more detailed description of all the functions available in the package and the input formats for each function. # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) NYCMafiaNodes is a node table with label and spatial coordinates for each node (a mafia member). NYCMafiaeEdges contains pairs of node labels (corresponding to node table label), representing mafia criminal associations. This is a unweighted and undirected network. The coordinate system crs is 32118, in the unit of meters. Data in POINodes and POIEdges are processed from SafeGraph with extra filters and coding to hide sensitive information. The dataset is meant to be educational and thus can be inaccurate for real implications. The nodes in the dataset are restaurants in Atlanta (set 0) and centroids of census block group (set 1). The edges in the dataset are visits from the census block group to restaurants. The weight of the edges represent the percentage of total visits coming from a particular census block group. You can call POINodes (n=1356) and POIEdges (n=7926) to directly access the sample dataset. The coordinates system is transformed with crs=26967 (unit meter). 6.2.1 Calculate K-fullfillment values To get K-fullfillment value for each node, you just need to run your node and edge dataframe through the following codes: library(SSNtools) data(NYCMafiaNodes) data(NYCMafiaEdges) # ----process dataframe into a list of lists # params: # data - a R dataframe containing node label, longitude, and latitude # label_name - the name of the column for node label # lon_name - the name of the column for node longitude # lat_name - the name of the column for node latitude # bipartite_name - (optional) the name of the column that indicates the bipartite set of the nodes. The set of nodes that EdgeScan or NDScan should report on should be coded as 1 in the biparite column, and 0 otherwise. nodes = processNode(NYCMafiaNodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;) # params: # data - a R dataframe containing source node label and target node label # source_name - the name of the column for source node label # target_name - the name of the column for target node label # weight_name - (optional) the name of the column for edge weight edges = processEdge(NYCMafiaEdges, &#39;Source&#39;, &#39;Target&#39;) # params: # nodes - a list of named lists. Each sublist contains a node. # edges - a list of list. Each sublist contains an edge. # minK - (optional) minimum K (degree) for a node to have K-fullfillment value. Default to minK = 1. # bipartite - (optional) whether the K-fullfillment will only be reported for nodes whose bipartite column is coded as 1. Default to FALSE. # return: # list(nodelist, edgelist) - a list of two dataframe for node and edge table. results = Kfullfillment(nodes, edges) nodelist = results[[1]] edgelist = results[[2]] nodelist[c(1:3), ] ## label K K_fullfillment ## 1 AMAROSA-ALEXANDER 3 0.33333333 ## 2 VINTALORO-JAMES 6 0.00000000 ## 3 TANTILLO-ENRICO 12 0.08333333 edgelist[c(1:3), ] ## Source Target is_K_nearest_neighbor ## 1 SALERNO-ANTHONY ALBERO-CHARLES 0 ## 2 CARUSO-FRANK NOBILE-GEORGE 0 ## 3 LISI-GAETANO MARI-FRANK 1 Interpret Outputs Kfullfillment() will return a list of two dataframes. The first dataframe is a node dataframe wtih three columns: label: the node label K: the node’s degree K, which is the same K for the node’s K-nearest neighbors. K-fullfillment: the percentage of a node’s K-nearest neighbors that it is connected. Nodes that are exclusively connected to their nearest neighbors will have a k-fulfillment value of 1. The second dataframe is an edge dataframe that has three columns: Source: source node label Target: target node label is_K_nearest_neighbor: binary value (1 or 0) indicating whether the edge represented a connection that is also within the source or target node’s K-nearest neighbors. 6.2.2 Visualize K-fullfillment To visualize Kfullfillment values on the node level, you can use the following codes as a reference. # packages for wrangling data and map visualization library(tmap) library(tidyverse) library(sf) library(stplanr) library(basemaps) # convert heat dataframe to a spatial sf object MafiaSpatial = nodelist %&gt;% left_join(NYCMafiaNodes, by=c(&#39;label&#39;), copy=FALSE) %&gt;% st_as_sf(coords=c(&#39;LonX&#39;, &#39;LatY&#39;), crs=32118) # convert edgelist dataframe to line geometry NYCMafiaEdges_shp = od2line(edgelist, MafiaSpatial) # create basemap with functions from basemaps library set_defaults(map_service = &quot;carto&quot;, map_type = &quot;light&quot;) bgbox = st_bbox(MafiaSpatial) %&gt;% st_as_sfc() bg = basemap_stars(bgbox) ## Loading basemap &#39;light&#39; from map service &#39;carto&#39;... tmap_mode(&#39;plot&#39;) g = # map base map tm_shape(bg) + tm_rgb(alpha=0.8) + # map all edges in grey tm_shape(NYCMafiaEdges_shp) + tm_lines(alpha=0.5, col=&#39;grey&#39;) + # map edges that also connect to K-nearest neighbors in black tm_shape(NYCMafiaEdges_shp %&gt;% filter(is_K_nearest_neighbor == 1)) + tm_lines(alpha=0.5, col=&#39;black&#39;) + # map nodes colored by K_fullfillment. Nodes with higher K_fullfillment values mapped last. tm_shape(MafiaSpatial %&gt;% arrange(K_fullfillment)) + tm_symbols(col=&#39;K_fullfillment&#39;, size=0.1, style=&#39;fixed&#39;, breaks=c(0, 0.00001, 0.10, 0.25, 1), palette = c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;), legend.col.show = FALSE) + # customize legend and layout tm_add_legend(type=&#39;symbol&#39;, labels=c(&#39;0&#39;, &#39;(0, 0.10]&#39;, &#39;(0.10, 0.25]&#39;, &#39;(0.25, 1]&#39;, &#39;NA (Less than minK)&#39;), col=c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;, &#39;grey&#39;), is.portrait = T, title=c(&#39;K-fullfillment&#39;), size=0.5) + tm_add_legend(type=&#39;line&#39;, labels=c(&#39;Edges also Connect to KNN&#39;, &#39;All Edges&#39;), col=c(&#39;black&#39;, &#39;grey&#39;), lwd=1) + tm_scale_bar(breaks=c(0, 5, 10), text.size = 0.7, position=c(0.78,0.9)) + tm_layout(legend.title.size = 0.9, legend.text.size = 0.7, legend.width = 1) + tm_layout(main.title = &#39;NYC Mafia SSN K-fullfillment&#39;, main.title.position = c(&#39;center&#39;), main.title.size = 1.5) g 6.2.3 Application to a bipartite network To calculate K-fullfillment values on the node level for a bipartite network, you can use the following codes as a reference. Note that only nodes whose Bipartite column is equal to 1 (in this case, POIs) will have K-fullfillment values. library(SSNtools) data(POINodes) data(POIEdges) POINodes[c(1,2,1046),] # label Bipartite LonX LatY # 1 poi1 1 682812.1 418009.0 # 2 poi2 1 681756.2 417956.0 # 1046 131210016001 0 682506.8 417742.6 POIEdges[c(1:3),] # # Source Target Weight # 1 poi1 130890204001 14.545455 # 2 poi1 130890205002 7.272727 # 3 poi1 131210001002 7.272727 nodes = processNode(POINodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;, &#39;Bipartite&#39;) edges = processEdge(POIEdges, &#39;Source&#39;, &#39;Target&#39;, &#39;Weight&#39;) results = Kfullfillment(nodes, edges, minK=1, bipartite=TRUE) nodelist = results[[1]] edgelist = results[[2]] nodelist[c(1:3),] # label K K_fullfillment # 1 poi1 11 0.3636364 # 2 poi2 15 0.3333333 # 3 poi3 7 0.4285714 edgelist[c(1:3),] # Source Target is_K_nearest_neighbor # 1 poi1 130890204001 1 # 2 poi1 130890205002 0 # 3 poi1 131210001002 0 6.3 Flattening Ratio Global Flattening Ratio is a network-level metric to measure the spatial tightness of a network. We reference the following definition in the paper Metrics for characterizing network structure and node importance in Spatial Social Network (Sarkar et al., 2019). To define the flattening ratio, we first create a degree-constrained nearest neighbour network \\(\\bar{G}\\) from the given social network G by reconfiguration, such that each node i in \\(\\bar{G}\\) with degree K connects to its nearest K neighbors in Euclidean space. As such, the (global) flattening ratio is the ratio of the sum of the Euclidean distance of edges in \\(\\bar{G}\\) where all nodes are connected to their K-nearest neighbors versus the sum of the Euclidean distance of actual edges in G. Note that many \\(\\bar{G}\\) can be possible for one G. Here is an example: Figure 6.2: Different \\(\\bar{G}\\) can be possible for one G In the Figure 6.2 above, every node has degree K equals to 2. In the first network, G1 = \\(\\bar{G1}\\) because the network G1 is already spatially efficient (i.e., every node connects to its two nearest neighbors). In the second network, two \\(\\bar{G}\\) (\\(\\bar{G2.1}\\) and \\(\\bar{G2.2}\\)) are possible for G2. If we reroute the network G2 in the node order of A -&gt; B -&gt; C -&gt; D, then we have \\(\\bar{G2.1}\\) because when it loops to node C or D, both A, B, and C have satisfied the degree constraints (K=2). The sum of distance for \\(\\bar{G2.1}\\) is 1+1+Sqrt(2). However, if the node order is A -&gt; D -&gt; B -&gt; C, then when it loops to B and C, all nodes have satisfied the degree constraints (K=2). The sum of distance for \\(\\bar{G2.2}\\) is 1+1+Sqrt(5)+Sqrt(5). Thus, the sum of distance for \\(\\bar{G2}\\) is the average sum of distance for \\(\\bar{G2.1}\\), \\(\\bar{G2.2}\\), etc. Our GlobalFlatteningRatio() function will allow users to select how many iterations (i.e., randomly generated order of nodes) they would like to use to calculate the average sum of distance. Local Flattening Ratio is a node-level metric, adapted from the Global Flattening Ratio definition. It is defined as the ratio of a node’s minimized distance (d_opt) needed to connect to any k nearest neighbors to the total actual distance (d_act) of its connections. Nodes with low values prioritize distant connections. This metric is similar to K-fullfillment, as both describe local (dis)connection. Our implementation of the Global and Local Flattening Ratio in SSNtools assume that the network is undirected and unweighted. These two concepts can also be applied to bipartite networks. In bipartite networks, a node (in set 1)’s K nearest neighbors can only be nodes in set 0. Here are some example research questions that can be answered by the Global/Local Flattening Ratio metric: (Global Flattening Ratio) Is the SSN spatially efficient? In another word, do nodes prefer to connect to their nearest neighbors or far friends? (Local Flattening Ratio) Which SSN node tends to connect to their neighbors (or have the most spatially tight social connections)? Our tutorial will cover the following topics: How to calculate Global Flattening Ratio values on the node level using GlobalFlatteningRatio() in SSNtools. How to calculate Local Flattening Ratio values on the node level using LocalFlatteningRatio() in SSNtools. How to visualize Local Flattening Ratio values on the node level and connections to the nearest neighbors. We will continue to use sample dataset NYCMafiaNodes, NYCMafiaEdges, POINodes, and POIEdges in SSNtools to illustrate examples. To load the sample dataset and the functions, go to GitHub SSNtool to download the development R package, or type the following lines in your R console. Click the GitHub page for more detailed description of all the functions available in the package and the input formats for each function. # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) NYCMafiaNodes is a node table with label and spatial coordinates for each node (a mafia member). NYCMafiaeEdges contains pairs of node labels (corresponding to node table label), representing mafia criminal associations. This is a unweighted and undirected network. The coordinate system crs is 32118, in the unit of meters. Data in POINodes and POIEdges are processed from SafeGraph with extra filters and coding to hide sensitive information. The dataset is meant to be educational and thus can be inaccurate for real implications. The nodes in the dataset are restaurants in Atlanta (set 0) and centroids of census block group (set 1). The edges in the dataset are visits from the census block group to restaurants. The weight of the edges represent the percentage of total visits coming from a particular census block group. You can call POINodes (n=1356) and POIEdges (n=7926) to directly access the sample dataset. The coordinates system is transformed with crs=26967 (unit meter). 6.3.1 Calculate Global Flattening Ratio To get the Global Flattening Ratio for your network, you just need to run your node and edge dataframe through the following codes. Because the random generation of node orders can be different every time and across different machines, you are expected to get slightly different result than what is shown in the tutorial. set.seed() may help you get the exact same outcome. Here, our data have 298 nodes, so we try 100 different node orders to calculate the average values for \\(\\bar{G}\\). You should scale your iterations based on the size of your network. library(SSNtools) data(NYCMafiaNodes) data(NYCMafiaEdges) # ----process dataframe into a list of lists # params: # data - a R dataframe containing node label, longitude, and latitude # label_name - the name of the column for node label # lon_name - the name of the column for node longitude # lat_name - the name of the column for node latitude # bipartite_name - (optional) the name of the column that indicates the bipartite set of the nodes. The set of nodes that EdgeScan or NDScan should report on should be coded as 1 in the biparite column, and 0 otherwise. nodes = processNode(NYCMafiaNodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;) # params: # data - a R dataframe containing source node label and target node label # source_name - the name of the column for source node label # target_name - the name of the column for target node label # weight_name - (optional) the name of the column for edge weight edges = processEdge(NYCMafiaEdges, &#39;Source&#39;, &#39;Target&#39;) # run both lines to get consistent GlobalFlatteningRatio results set.seed(1234, &quot;Mersenne-Twister&quot;, sample.kind=&quot;Rounding&quot;) # params: # nodes - a list of named list; each sublist is a node # edges - a list of named list; each sublist is an edge # iter - the number of iterations for node orders GlobalFlatteningRatio(nodes, edges, 100) ## [1] 0.1940646 Interpret Outputs Global Flattening Ratio reports 0.1940646 for our mafia network, which means that the mafia network is not very spatially tight. In another word, mafia members prefer far friends rather than connections to nearest neighbors. This result makes sense because mafia members are likely to connect to other mafia members in the same families and these members spread out in geographic space. 6.3.2 Calculate Local Flattening Ratio To get Local Flattening Ratio value for each node, you just need to run your node and edge dataframe through the following codes: library(SSNtools) data(NYCMafiaNodes) data(NYCMafiaEdges) # ----process dataframe into a list of lists # params: # data - a R dataframe containing node label, longitude, and latitude # label_name - the name of the column for node label # lon_name - the name of the column for node longitude # lat_name - the name of the column for node latitude # bipartite_name - (optional) the name of the column that indicates the bipartite set of the nodes. The set of nodes that EdgeScan or NDScan should report on should be coded as 1 in the biparite column, and 0 otherwise. nodes = processNode(NYCMafiaNodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;) # params: # data - a R dataframe containing source node label and target node label # source_name - the name of the column for source node label # target_name - the name of the column for target node label # weight_name - (optional) the name of the column for edge weight edges = processEdge(NYCMafiaEdges, &#39;Source&#39;, &#39;Target&#39;) # params: # nodes - a list of named lists. Each sublist contains a node. # edges - a list of list. Each sublist contains an edge. # minK - (optional) minimum K (degree) for a node to have Local_flattening_ratio value. Default to minK = 1. # bipartite - (optional) whether the Local_flattening_ratio will only be reported for nodes whose bipartite column is coded as 1. Default to FALSE. # return: # list(nodelist, edgelist) - a list of two dataframe for node and edge table. results = LocalFlatteningRatio(nodes, edges) nodelist = results[[1]] edgelist = results[[2]] nodelist[c(1:3), ] ## label K Local_flattening_ratio ## 1 AMAROSA-ALEXANDER 3 0.81895190 ## 2 VINTALORO-JAMES 6 0.07881283 ## 3 TANTILLO-ENRICO 12 0.12986306 edgelist[c(1:3), ] ## Source Target is_K_nearest_neighbor ## 1 SALERNO-ANTHONY ALBERO-CHARLES 0 ## 2 CARUSO-FRANK NOBILE-GEORGE 0 ## 3 LISI-GAETANO MARI-FRANK 1 Interpret Outputs LocalFlatteningRatio() will return a list of two dataframes. The first dataframe is a node dataframe wtih three columns: label: the node label K: the node’s degree K, which is the same K for the node’s K-nearest neighbors. Local_flattening_ratio: the ratio of the sum of Euclidean distance between a node and its K-nearest neighbors (K is the node’s degree) versus the sum of Euclidean distance between a node and all other nodes it connects to. The value is ranged between 0 and 1. The second dataframe is an edge dataframe that has three columns: Source: source node label Target: target node label is_K_nearest_neighbor: binary value (1 or 0) indicating whether the edge represented a connection that is also within the source or target node’s K-nearest neighbors. 6.3.3 Visualize Local Flattening Ratio To visualize Local Flattening Ratio values on the node level, you can use the following codes as a reference. # packages for wrangling data and map visualization library(tmap) library(tidyverse) library(sf) library(stplanr) library(basemaps) # convert heat dataframe to a spatial sf object MafiaSpatial = nodelist %&gt;% left_join(NYCMafiaNodes, by=c(&#39;label&#39;), copy=FALSE) %&gt;% st_as_sf(coords=c(&#39;LonX&#39;, &#39;LatY&#39;), crs=32118) # convert edgelist dataframe to line geometry NYCMafiaEdges_shp = od2line(edgelist, MafiaSpatial) # create basemap with functions from basemaps library set_defaults(map_service = &quot;carto&quot;, map_type = &quot;light&quot;) bgbox = st_bbox(MafiaSpatial) %&gt;% st_as_sfc() bg = basemap_stars(bgbox) ## Loading basemap &#39;light&#39; from map service &#39;carto&#39;... tmap_mode(&#39;plot&#39;) g = # map base map tm_shape(bg) + tm_rgb(alpha=0.8) + # map all edges in grey tm_shape(NYCMafiaEdges_shp) + tm_lines(alpha=0.5, col=&#39;grey&#39;) + # map edges that also connect to K-nearest neighbors in black tm_shape(NYCMafiaEdges_shp %&gt;% filter(is_K_nearest_neighbor == 1)) + tm_lines(alpha=0.5, col=&#39;black&#39;) + # map nodes colored by Local_flattening_ratio. Nodes with higher Local_flattening_ratio values mapped last. tm_shape(MafiaSpatial %&gt;% arrange(Local_flattening_ratio)) + tm_symbols(col=&#39;Local_flattening_ratio&#39;, size=0.1, style=&#39;fixed&#39;, breaks=c(0, 0.05, 0.1, 0.15, 1), palette = c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;), legend.col.show = FALSE) + #customize legend and layout tm_add_legend(type=&#39;symbol&#39;, labels=c(&#39;(0, 0.05]&#39;, &#39;(0.05, 0.10]&#39;, &#39;(0.10, 0.15]&#39;, &#39;(0.15, 1]&#39;, &#39;NA (Less than minK)&#39;), col=c(&#39;#FBD977&#39;, &#39;#F78D3D&#39;, &#39;#E3211B&#39;, &#39;#800F26&#39;, &#39;grey&#39;), is.portrait = T, title=c(&#39;Local Flattening Ratio&#39;), size=0.5) + tm_add_legend(type=&#39;line&#39;, labels=c(&#39;Edges also Connect to KNN&#39;, &#39;All Edges&#39;), col=c(&#39;black&#39;, &#39;grey&#39;), lwd=1) + tm_scale_bar(breaks=c(0, 5, 10), text.size = 0.7, position=c(0.78,0.9)) + tm_layout(legend.title.size = 0.9, legend.text.size = 0.7, legend.width = 1, main.title = &#39;NYC Mafia SSN Local Flattening Ratio&#39;, main.title.position = c(&#39;center&#39;), main.title.size = 1.2) g 6.3.4 Application to a bipartite network To calculate Local Flattening Ratio values on the node level for a bipartite network, you can use the following codes as a reference. Note that only nodes whose Bipartite column is equal to 1 (in this case, POIs) will have Local Flattening Ratio values. library(SSNtools) data(POINodes) data(POIEdges) # show example outputs in the sample data POINodes[c(1,2,1046),] # label Bipartite LonX LatY # 1 poi1 1 682812.1 418009.0 # 2 poi2 1 681756.2 417956.0 # 1046 131210016001 0 682506.8 417742.6 POIEdges[c(1:3),] # # Source Target Weight # 1 poi1 130890204001 14.545455 # 2 poi1 130890205002 7.272727 # 3 poi1 131210001002 7.272727 nodes = processNode(POINodes, &#39;label&#39;, &#39;LonX&#39;, &#39;LatY&#39;, &#39;Bipartite&#39;) edges = processEdge(POIEdges, &#39;Source&#39;, &#39;Target&#39;, &#39;Weight&#39;) results = LocalFlatteningRatio(nodes, edges, minK=1, bipartite=TRUE) nodelist = results[[1]] edgelist = results[[2]] nodelist[c(1:3),] # label K Local_flattening_ratio # 1 poi1 11 0.2400992 # 2 poi2 15 0.3255136 # 3 poi3 7 0.3924708 edgelist[c(1:3),] # Source Target is_K_nearest_neighbor # 1 poi1 130890204001 1 # 2 poi1 130890205002 0 # 3 poi1 131210001002 0 6.4 Linked Activity Spaces Linked Activity Spaces is a concept introduced in paper Linked Activity Spaces: Embedding Social Networks in Urban Space (Wang et al., 2015) to measure to what extent nodes connected also overlap in their associated locations. This concept applies to networks where the nodes represent egos (e.g., individuals; also called primary nodes) and the locations associated with egos (e.g., places the individuals have visited), while the edges represent connections between egos and their alters (e.g., friends; also called linked nodes). In Wang et al., 2015, an ego is a cell phone user, alters are users who have phone calls with this user, and the locations associated with the users are POIs that the users have visited. An Activity Space refers to the areas captured by the standard deviation ellipse given an ego’s associated locations. Thus, Linked Activity Spaces refers to a pair of activity spaces of an ego and its alters. We quantify the overlaps between linked activity spaces using the number of locations (e.g., POIs) found in the intersections of activity spaces, as defined in Wang et al., 2015. Here are some example research questions that can be answered by the Linked Activity Spaces visualization and metric: Do egos visit the same set of places as its alters? Which alter (given an ego) has activity space overlapping the most with the ego? Our tutorial will cover the following topics: How to visualize a selected ego’s and its alters’ activity spaces (i.e., two ellipses), using ggplot2 How to visualize a selected ego’s activity space and each of its alters’ activity spaces (i.e., linked activity spaces), using ggplot2 How to quantify the overlap between a ego and its alters’ activity spaces (i.e., number of nodes in both ellipses) How to quantify the overlap between a ego and each of its alters’ activity spaces (i.e., number of nodes in each pair of ellipses) We will use a new sample dataset EmergencyNodes and EmergencyEdges in SSNtools to illustrate examples. To load the sample dataset and the functions, go to GitHub SSNtool to download the development R package, or type the following lines in your R console. Click the GitHub page for more detailed description of all the functions available in the package and the input formats for each function. # install.packages(&quot;devtools&quot;) devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) A row in EmergencyNodes (n=1582) represents a New York City emergency responder (label) and locations where the responder have been dispatched (LonX, LatY). The coordinate system is in crs = 4326. A row in EmergencyEdges (n=47) represents two responders (Source, Target) who had been paired in a dispatch. Note that one responder can be dispatched multiple times and thus be associated with multiple locations in EmergencyNodes, while EmergencyEdges only documents the pairing once as long as the two repsonders have been paired up before. The network is unweighted and undirected. As such, linked activity spaces method can help examine the efficiency of emergency management, such as whether respondents who are often paired together also tend to go to the same emergency locations. 6.4.1 Visualize Linked Activity Spaces The sample dataset contains data for two egos (primary nodes; labeled as P1 and P2) and their associated alters (linked nodes). We would like to focus on one primary node, P1, to demonstrate the method. The additional primary node (P2) is included in the sample dataset as an extra example for exploration. We would like to thank Sambhavi Joshi for contributing to the codes below. We first filter EmergencyNodes and EmergencyEdges to data that are relevant to P1 and take a look at the data. Then we use ggplot2() to visualize locations associated with P1, the primary node, and its linked nodes. Note that basemap_gglayer() defaults the input data has crs 3857, so we have to convert our data from crs 4326 to 3857. library(SSNtools) library(ggplot2) library(basemaps) library(tidyverse) library(sf) data(EmergencyNodes) data(EmergencyEdges) # filter edges that contain the ego ego_label = &#39;P1&#39; ego_alters_pairs = EmergencyEdges %&gt;% filter(Source == ego_label | Target == ego_label) ego_alters_pairs[c(1:3),] ## Source Target ## 1 P1 P30 ## 2 P1 P26 ## 3 P23 P1 # filter emergency locations associated with ego and its alters in node list ego_alters_locations = EmergencyNodes %&gt;% filter(label %in% ego_alters_pairs$Source | label %in% ego_alters_pairs$Target) %&gt;% mutate(role = ifelse(label == ego_label, &#39;Primary Node&#39;, &#39;Linked Node&#39;)) ego_alters_locations[c(1,2,46),] ## label LonX LatY role ## 1 P1 -73.92782 40.76762 Primary Node ## 2 P1 -73.92457 40.76927 Primary Node ## 46 P3 -73.92782 40.76762 Linked Node # visualize locations visited by the primary nodes and linked nodes; # basemap_gglayer assumes data comes in with crs=3857, so transform the coordinates from crs 4326 to 3857 ego_alters_locations = ego_alters_locations %&gt;% st_as_sf(coords=c(&#39;LonX&#39;, &#39;LatY&#39;), crs=4326) %&gt;% st_transform(crs=3857) %&gt;% mutate(LonX = sf::st_coordinates(.)[,1], LatY = sf::st_coordinates(.)[,2]) %&gt;% mutate(role = factor(role, levels=c(&#39;Primary Node&#39;, &#39;Linked Node&#39;))) # create basemap set_defaults(map_service = &quot;carto&quot;, map_type = &quot;light&quot;) bgbox = st_bbox(ego_alters_locations %&gt;% st_as_sf(coords=c(&#39;LonX&#39;, &#39;LatY&#39;), crs=3857)) %&gt;% st_as_sfc() g1 = # map basemap ggplot() + basemap_gglayer(bgbox) + scale_fill_identity() + # map locations associated with both the primary node and linked nodes. geom_point(data = ego_alters_locations, aes(x =LonX, y=LatY, color=role, size=role)) + # customize aesthetics and the layout scale_size_manual(values = c(`Primary Node` = 5, `Linked Node` = 2), name=&#39;Emergency Locations Visited by&#39;) + scale_color_manual(values = c(`Primary Node` = &#39;darkred&#39;, `Linked Node` = &#39;orange&#39;), name=&#39;Emergency Locations Visited by&#39;) + coord_sf() + theme_void() + theme(legend.position = &quot;bottom&quot;, axis.title.x=element_blank(), axis.title.y=element_blank()) ## Loading basemap &#39;light&#39; from map service &#39;carto&#39;... g1 Not surprisingly, we can see that emergency locations visited by the linked nodes are more widespread than those visited by the primary node, with most overlaps in the northeast section of the map. Next, we would like to visualize the activity spaces as ellipses. To add eclipses to the map above, we just need to add a layer in ggplot using stat_ellipse(). You can control the size (or coverage) of ellipses by adjusting the level argument. Here, level = 0.8 means the ellipse covers about 80% of the data points. # visualize standard deviation ellipses for locations visited by the primary node and linked nodes. g2 = # map basemap ggplot() + basemap_gglayer(bgbox) + scale_fill_identity() + # map locations associated with both the primary node and linked nodes. geom_point(data = ego_alters_locations, aes(x =LonX, y=LatY, color=role, size=role)) + scale_size_manual(values = c(`Primary Node` = 5, `Linked Node` = 2), name=&#39;Activity Space by&#39;) + scale_color_manual(values = c(`Primary Node` = &#39;darkred&#39;, `Linked Node` = &#39;orange&#39;), name=&#39;Activity Space by&#39;) + # map activity space in the form of ellipses stat_ellipse(data = ego_alters_locations, geom = &quot;polygon&quot;, aes(x=LonX, y=LatY, group=role, color=role), type = &quot;norm&quot;, alpha=0, linetype=&#39;dashed&#39;, level = 0.8) + coord_sf() + theme_void() + ggtitle(&#39;A Pair of Activity Spaces&#39;) + theme(legend.position = &quot;bottom&quot;, axis.title.x=element_blank(), axis.title.y=element_blank(), plot.title = element_text(hjust = 0.5)) ## Loading basemap &#39;light&#39; from map service &#39;carto&#39;... g2 The map confirms that the primary node has a smaller activity space than the linked nodes. The two activity spaces overlap quite a bit as expected, because the primary node visits the emergency locations with at least one other linked node. We are interested to explore further how the primary node’s activity space overlaps with each linked node (i.e., Linked Activity Spaces). We only need to modify the codes above slightly, by adding group = label in the stat_ellipse() function. Now the codes will draw a ellipse for each responders’ dispatched locations. # visualize standard deviation ellipses of locations visited by each unique responders g3 = # map basemap ggplot() + basemap_gglayer(bgbox) + scale_fill_identity() + # map locations associated with both the primary node and linked nodes. geom_point(data = ego_alters_locations, aes(x =LonX, y=LatY, color=role, size=role)) + scale_size_manual(values = c(`Primary Node` = 5, `Linked Node` = 2), name=&#39;Activity Space by&#39;) + scale_color_manual(values = c(`Primary Node` = &#39;darkred&#39;, `Linked Node` = &#39;orange&#39;), name=&#39;Activity Space by&#39;) + # map activity space in the form of ellipses stat_ellipse(data = ego_alters_locations, geom = &quot;polygon&quot;, aes(x=LonX, y=LatY, group=label, color=role), type = &quot;norm&quot;, alpha=0, linetype=&#39;dashed&#39;, level = 0.8) + coord_sf() + theme_void() + ggtitle(&#39;Linked Activity Spaces&#39;) + theme(legend.position = &quot;bottom&quot;, axis.title.x=element_blank(), plot.title = element_text(hjust = 0.5)) ## Loading basemap &#39;light&#39; from map service &#39;carto&#39;... g3 We can roughly see three clusters of linked nodes’ activity spaces. One cluster of ellipses overlap closely with the primary node’s ellipse. The other cluster of ellipses overlap partially with the primary node’s ellipse while also going to locations toward the south (east of the river). However, there are about three elipses on the west bank of the river that have little overlaps with the primary node’s ellipse. It indicates that these three linked nodes (emergency responders) tend to have very different dispatch locations than the primary node. Next, we would like to further quantify the intersection between the activity spaces. 6.4.2 Quantify Linked Activity Spaces We quantify the intersection between activity spaces as the number of nodes (in this case, emergency locations) in between the ellipses. We reference this Stack Overflow post to generate the codes below. Let’s first quantify the intersection for g2 (see the map for g2 above). ggplot_build() returns a list containing several data frames, one for each layer in the plot. In my case, there are three layers: basemap_gglayer, geom_point, and stat_ellipse. Thus, points and ellipse data correspond to the second and third data frames. ellipse_sf is an sf object with two geometries (because we drew two ellipses). Thus, points_in_ellipses will return a list of integer vectors, in which an empty vector means the point is not inside either ellipses; one element (1 or 2) means the point is inside ellipse 1 or 2 (the number refers to the group associated with the ellipses); two elements (1 and 2) means that the point is inside both ellipses. # retrieve points and ellipse data. build &lt;- ggplot_build(g2)$data points &lt;- build[[2]] ellipse &lt;- build[[3]] # Convert ellipse data to sf polygons; ellipse_sf is an sf object with two geometries ellipse_sf &lt;- ellipse %&gt;% st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;), crs = 3857) %&gt;% group_by(group) %&gt;% summarise(geometry = st_combine(geometry)) %&gt;% st_cast(&quot;POLYGON&quot;) ellipse_sf ## Simple feature collection with 2 features and 1 field ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -8232963 ymin: 4975299 xmax: -8227866 ymax: 4979577 ## Projected CRS: WGS 84 / Pseudo-Mercator ## # A tibble: 2 × 2 ## group geometry ## &lt;int&gt; &lt;POLYGON [m]&gt; ## 1 1 ((-8228259 4978079, -8228268 4978264, -8228297 4978447, -8228344 497862… ## 2 2 ((-8227866 4977535, -8227886 4977787, -8227943 4978033, -8228039 497826… # Check if each point in the ego_alters_locations dataset is within the respective ellipses points_in_ellipses &lt;- st_within(ego_alters_locations, ellipse_sf) # example outputs in points_in_ellipses points_in_ellipses[c(1,3,12)] ## [[1]] ## [1] 1 2 ## ## [[2]] ## [1] 2 ## ## [[3]] ## integer(0) # calculate the number of points that are in both ellipses sum(lengths(points_in_ellipses) &gt; 1) ## [1] 399 Great! We have quantified intersection between one pair of activity spaces. For Linked Activity Spaces, we would like to know this value for each linked node so that we can see which responders’ activity space overlap the most with the primary node. We just need to modify the codes above slightly and use outputs from g3. Note that this time ellipse_sf will have 22 geometries (22 ellipses for 22 linked nodes). Since in stat_ellipse(), ellipses are drawn by group based on the order of labels. Thus, primary node’s ellipse is assigned to group 1 (i.e., 1). We create a loop to loop through each linked node’s ellipse (starting from group 2) and count the number of locations in the intersection of the primary node’s ellipse and the linked node’s ellipse. # retrieve points and ellipse data. build &lt;- ggplot_build(g3)$data points &lt;- build[[2]] ellipse &lt;- build[[3]] # convert ellipse data to sf polygons; ellipse_sf is an sf object with twenty-two geometries ellipse_sf &lt;- ellipse %&gt;% st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;), crs = 3857) %&gt;% group_by(group) %&gt;% summarise(geometry = st_combine(geometry)) %&gt;% st_cast(&quot;POLYGON&quot;) nrow(ellipse_sf) ## [1] 22 # loop through each linked node&#39;s ellipse (starting from group 2) and count the number of locations in the intersection. cnt = c() for (grp in c(2:nrow(ellipse_sf))) { points_in_ellipses &lt;- st_within(ego_alters_locations, ellipse_sf %&gt;% filter(group %in% c(1, grp))) n_nodes_in_both_ellipses &lt;- sum(lengths(points_in_ellipses) &gt; 1) cnt = c(cnt, n_nodes_in_both_ellipses) } #pair up nodes and the number of nodes in P1&#39;s ellipse and this linked node&#39;s ellipse. data.frame(label = unique(ego_alters_locations$label), n_nodes_in_both_ellipses = c(NA, cnt)) ## label n_nodes_in_both_ellipses ## 1 P1 NA ## 2 P3 409 ## 3 P4 395 ## 4 P8 409 ## 5 P10 137 ## 6 P11 320 ## 7 P13 193 ## 8 P14 368 ## 9 P17 392 ## 10 P19 360 ## 11 P20 315 ## 12 P22 353 ## 13 P23 315 ## 14 P25 382 ## 15 P26 360 ## 16 P28 392 ## 17 P29 159 ## 18 P30 360 ## 19 P31 0 ## 20 P32 0 ## 21 P33 101 ## 22 P38 0 The result confirms our observations above: there are three linked nodes (P31, P32, P38) that have zero location overlaps with the primary node. While these responders may be paired with the primary node (P1) for few tasks, it is worth looking into why they are paired to improve the emergency management. In contrast, P3 and P8’s activity spaces overlap with the primary node (P1) the most. 6.4.2.1 Reference Liang, X., Baker, J., DellaPosta, D., &amp; Andris, C. (2023). Is your neighbor your friend? Scan methods for spatial social network hotspot detection. Transactions in GIS. https://doi.org/10.1111/tgis.13050 Andris, C., DellaPosta, D., Freelin, B. N., Zhu, X., Hinger, B., &amp; Chen, H. (2021). To racketeer among neighbors: spatial features of criminal collaboration in the American Mafia. International Journal of Geographical Information Science, 35(12), 2463-2488. Sarkar, D., Andris, C., Chapman, C. A., &amp; Sengupta, R. (2019). Metrics for characterizing network structure and node importance in Spatial Social Networks. International Journal of Geographical Information Science, 33(5), 1017-1039. Wang, Y., Kang, C., Bettencourt, L. M., Liu, Y., &amp; Andris, C. (2015). Linked activity spaces: Embedding social networks in urban space. Computational approaches for urban environments, 313-336. "],["development.html", "Chapter 7 Future Development", " Chapter 7 Future Development The development of this tutorial is funded under NSF Career Grant: A Research and Educational Framework for Incorporating Spatial Heterogeneity into Social Network Analysis. Please visit our website SNoMaN (The Social Network Mapping Nexus) to see our SSN paper collection and interactive software. The future development of the tutorial includes: Advanced Metrics Regional Modularity Missed Opportunities Cluster/Cluster Plots Route Factor Diagrams Application Examples Commutes We are also considering more examples of topic applications using visualization and metrics. If you would like to contribute writing a chapter, sharing a sample dataset, or developing a metric in the SSNtools R package, please contact Xiaofan Liang at xiaofan.l@gatech.edu. If you run into an issue with the SSNtools R package or this tutorial, please open an issue at the GitHub with an replicable example. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
