[
["index.html", "Spatial Social Networks (SSN) Visualization and Metrics with R Chapter 1 Introduction", " Spatial Social Networks (SSN) Visualization and Metrics with R Xiaofan Liang, Clio Andris, Dipto Sarkar 2021-10-29 Chapter 1 Introduction This tutorial is dedicated to describe the basic concepts, methods, and visualizations involved to map and analyze non-planar networks (social networks &amp; relationships) in geographic space using R. A non-planar network is a network in which the nodes are geolocated, while the edges can cross over each other without creating new nodes. For example, mapping Facebook friendships and flight routes in geographic space are non-planar. A planar network is spatially embedded in a way that the edges intersect only at the endpoints, such as the road, river, and eletrical grid networks. There are already some tutorials for mapping and analyzing planar networks, but none exists for non-planar networks. We assume our audience has basic knowledge of R programming with Tidyverse pakcage and basic GIS concepts (e.g., basic geometry types, coordinate system projection, spatial operation etc.). If not, you can use this book Geocomputation with R to get started with the basic concepts. Mapping relationship in geographic space has its own challenges, which is described thoroughly in Andris’s paper Challenges for Social Flows. In our visualization examples, we will try to show the best practices to map social networks in space that can counter some of these problems. All the data you need to complete the tutorial will be downloaded from Friendly Cities Lab GitHub page. Required Packages We use igraph package to calculate network metrics, sf package to create geospatial objects from dataframe, tmap package to create both static and interactive maps, tmaptools package to extract OpenStreetMap basemaps, and tidyverse package as the syntax to process data. You can download the packages using the following codes: install.packages(&quot;igraph&quot;) #for network analysis install.packages(&quot;sf&quot;) #for spatial objects operation install.packages(&quot;tmap&quot;) #for mapping install.packages(&quot;tmaptools&quot;) #for using read.osm to extract basemaps install.packages(&quot;stars&quot;) #for using Mapbox to extract basemaps install.packages(&quot;tidyverse&quot;) #for data processing install.packages(&#39;tigris&#39;) #for loading TIGRR shapefiles install.packages(&quot;devtools&quot;) #to download R package on GitHub devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) There are a few packages for visualizing maps. We chose tmap in the end for its flexibility to switch between interactive maps and static plots. ggpplot2 has powerful mapping functions. It is intuitive for people who are used to the underlying logic of ggplot2. One advantage of ggpplot2 is that it can easily add high-resolution Google Maps as basemaps using ggmap package (only in WGS84 projection). Here are some good tutorials that teach you how to use ggplot2 to map planar networks and produce basic elements of a map. However, you need to convert spatial objects to dataframe for ggpplot2 to draw on. cartography has limited mapping functions, but can come in handy when you only need to draw a few simple types of maps. It has some functions that are very friendly for mapping spatial networks, such as getLinkLayer that takes in point shapefiles and edge tables and return edge shapefiles. You can also overlay proportional symbols and proportional links layers. However, you may not get to control the details of the maps in the most desirable ways. tmap is equally powerful as ggpplot2, and has the extra function to switch between a static plot and interactive plot mode. This feature is useful when you want to zoom in and out to explore your data. The interaction component is operationalized through Leaflet package. To draw basemaps with tmap, you can either use the read_osm function in tmaptools or use package stars to wrap around the raster downloaded through Mapbox API. For read_osm to work, you will need to install rJava for the function to run, which may further require downloading Java and Java Development kit. You can see Chapter X for examples to add basemaps. sf converts data frame into spatial objects that can be used in base R plot function and tmap. It can also conduct various spatial operation, such as coordinate system projection, spatial joins, and topological relations. A brief introduction of how to streamline sf and tmap is given in the book Geocomputation with R. igraph is the go-to package for network analysis, such as calculating the centrality measures of a network. These measures may become the attributes for nodes or edges in the maps. We will show the workflow from igraph to tmap with examples in Chapter X. tidyverse provides a set of packages that share the same data representation and use the pip symbol %&gt;% to connect steps of processing. tigris download geographic boundary shapefiles from TIGER website. SSNtools is an R package that provides metrics for analyzing and visualizing spatial social networks. "],
["metrics.html", "Chapter 2 Network Metrics 2.1 Network Data Formats 2.2 Network Metrics 2.3 igraph Visualization", " Chapter 2 Network Metrics In this chapter, we introduce the following topics: Data formats of network data Network metrics for nodes and edges How to visualize an igraph network graph We only introduce basic concepts here for reference. If you want to learn more about visualizing abstractions of networks (which are not geographically embedded) and network metrics, Katherine Ognyanova has an awesome tutorial here. 2.1 Network Data Formats Nodes and edges are the two key components of a network. Nodes may also refer as vertices (vertex for singular). There are two common data formats to store data for nodes and edges. The first one is an adjacency matrix (see 2.1 as an example), and the second one is a node table and an edge list (see 2.2 and 2.3 as an example). In a node table, one row contains all the attributes (e.g., degree, coordinates, values) for one node. In an edge table, one row represents an edge pair and all the attributes associated with the edge (e.g., weight). The following examples show data formats for a network using remittance data between China, Mexico, and Canada. Table 2.1: Adjacency Matrix China Mexico Canada China 0 48520 4144020 Mexico 2520 0 155790 Canada 19650 8980 0 Table 2.2: Node table Node_id Country_name Population_estimate Longitude Latitude 1 China 1338612970 103.11 35.69 2 Mexico 111211789 -102.18 23.73 3 Canada 33487208 -96.09 57.89 Table 2.3: Edge list Edge_id Origin Destination Remittance 1 China China 0 2 China Mexico 2520 3 China Canada 19650 4 Mexico China 48520 5 Mexico Mexico 0 6 Mexico Canada 8980 7 Canada China 4144020 8 Canada Mexico 155790 9 Canada Canada 0 2.2 Network Metrics igraph package provides functions that calculate a few network metrics for nodes and edges in an network. It can construct a network from the two common data formats: using graph_from_data_frame with a node table and an edgelist (edgelist alone works too) or graph_from_incident_matrix with an adjacency matrix. g = graph_from_data_frame(YOUR_EDGELIST, directed=TRUE) g = graph_from_data_frame(YOUR_EDGELIST, vertices=YOUR_NODETABLE, directed=TRUE) g = graph_from_incident_matrix(YOUR_MATRIX, directed=TRUE) Here are some common network metrics that are used to measure properties of nodes, edges, and network structure as a whole: 2.2.1 Network Metrics for Nodes Degree: measures the total connections of a node, regardless of the direction of the connections. V(g)$degree = degree(g, v=V(g), mode=c(&#39;all&#39;)) #add degree to nodes in the network g In Degree measures the total connections that flow to a node. V(g)$degree = degree(g, v=V(g), mode=c(&#39;in&#39;)) #add in degree to nodes in the network g Out Degree measures the total connections that flow out from a node. V(g)$degree = degree(g, v=V(g), mode=c(&#39;out&#39;)) #add out degree to nodes in the network g Weighted Degree measures the sum of the edge weights to a node, which is correlated with the degree of a node but weighted. The weighted in degree and weighted out degree use the same code, but change the mode to “in” and “out”. #Edgelist should include weight column for the code to work. V(g)$weighted_degree = strength(g, v=V(g), mode=c(&#39;all&#39;)) #add weighted degree to nodes in the network g Closeness Centrality measures the closeness of one node to all other nodes in the network. A high value means that a node, on average, can reach all other nodes in a few steps. It is calculated as the reciprocal of the sum of the length of the shortest path between a node and all other nodes in the graph. V(g)$closeness_centrality = closeness(g, vids=V(g), mode=&#39;in&#39;) #add closeness centrality (mode = &#39;in&#39; uses in degree as paths to a node) to nodes in the network g Betweenness Centrality measures the importance of a node in calculating the shortests paths of all nodes in a network. A high value means that a node, if removed from the network, will make the shortest path calculation longer for many other nodes in the network. It is calculated as the number of shortest paths that pass through the node. V(g)$betweenness_centrality = betweenness(g, v=V(g), directed=TRUE) #add betweenness centrality to nodes in the network g Eigenvector Centrality measures the influence a node has on a network. A node has high influence if it is connected to many nodes who themselves have high influences. V(g)$eigenvector_centrality = eigen_centrality(g, directed=TRUE) #add eigenvector centrality to nodes in the network g (Local) Clustering Coefficient measures how close the neighbors of a node all connect to each other, and thus how embedded a node is in its local networks. It is also called the local clustering coefficient. V(g)$clustering_coefficient = transitivity(g, type=&#39;local&#39;) #add local clustering coefficient to nodes in the network g Eccentricity measures the shortest path distance to the farthest other node in the network. V(g)$eccentricity = eccentricity(g, vids=V(g), mode=c(&#39;all&#39;)) #add eccentricity to nodes (path calculated as undirected) in the network g Shortest Path is the shortest path from one node to another in the network. It contains a list of nodes that the path passes by. get.shortest.paths(g, 1, 3) #give you the shortest path from node 1 to node 3. The path will show the number or the name of the nodes passed. Igraph package labels every node with a number. Hops is the number of steps for one node to jump to another node. length(get.shortest.paths(g, 1, 3)$vpath[[1]]) #measure the number of hops from node 1 to node 3 2.2.2 Network Metrics for Edges Weight can represent the value of the connection, such as volumes of flows or the extent of strength (e.g., trust). E(g)$weight = YOUR_WEIGHT_VECTOR #assign weights to edges Edge Betweenness measures the number of shortest paths pass through an edge. E(g)$edge_betweenness = edge_betweenness(g, e=E(g), directed=TRUE) #calculate edge_betweenness for all edges in a network For network structures: Diameter measures the maximum distance between any pairs of nodes in a network. In another word, it is the maximum eccentricity of any node. d = diameter(g, directed=FALSE) #calculate diameter of a network (Global) Clustering Coefficient measures the degree to which nodes in a network tend to cluster together. Global clustering coefficient is calculated as the ratio of the number of closed triplets and the total number of triplets. global_clustering_coefficient = transitivity(g, type=&#39;average&#39;) #calculate global clustering coefficient of a network Average Path Length measures the mean of the lengths of the shortest paths between all pairs of nodes in the network. avg_path_length = average.path.length(g, directed=FALSE) #calculate the average path length of a undirected network 2.3 igraph Visualization Here is an example using data about the American Mafia to visualize an igraph network. This data was collected by Dan DellaPosta at Penn State and published in the paper Network closure and integration in the mid-20th century American mafia. The node table contains: Name of the Mafia member Mafia family the member belongs to Whether the member is in New York City Longitude and Latitude of the location of the member The edge list contains pairs of undirected connections: Source (the name of a member) Target (the name of a different member) The node size varies by the values of local clustering coefficient, and the node color varies by the mafia family the node belongs to. library(igraph) library(SSNtools) #MafiaNodes and MafiaEdges are built-in datasets in SSNtools package g &lt;- graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaNodes) #set the node size to base on clustering coefficients V(g)$size &lt;- transitivity(g, type=&#39;local&#39;) #Set the node color to vary by mafia family group. # ---- get all color from a color device color = grDevices::colors()[grep(&#39;gr(a|e)y&#39;, grDevices::colors(), invert = T)] # ---- sample n color, in which n = family groups colrs &lt;- sample(color, length(unique(V(g)$Family))) # ---- #assign color to correpsonding mafia family member V(g)$color &lt;- colrs[as.numeric(factor(V(g)$Family))] #Plot igraph network plot(g, vertex.label = NA, vertex.color = V(g)$color, vertex.size = 50*V(g)$size, #Scaled node size edge.width=0.5, layout=layout_with_fr(g) ) #Add node color legend fname = sort(unique(V(g)$Family)) #sort the legend labels legend(x=-2.2, y=1.5, #legend position legend=fname, pch=21, #solid circle with one color pt.bg=colrs[as.numeric(factor(fname))], pt.cex=1, cex=.7, bty=&quot;n&quot;, ncol=1, title = &#39;Node Color: Family Group&#39; ) #Add node size legend # ---- quantile breaks to show node size breaks = round(quantile(V(g)$size, c(0.2, 0.4, 0.6, 0.8, 1)),2) legend(x = -2.2, y = -1.2, #legend position legend=breaks, pch=21, pt.bg=NA, #no color background cex=0.7, #size of legend pt.cex=breaks * 10, #Scaled node size bty=&quot;n&quot;, #node shape ncol=5, #number of column for legend text.width = 0.27, #adjust width of each column title = &#39;Node Size: Local Clustering Coefficient&#39;) "],
["nodes.html", "Chapter 3 Visualizing Nodes 3.1 Convert Coordinates to Points 3.2 Visualize Nodes 3.3 Visualize Nodes by Node Color 3.4 Visualize Nodes by Node Size 3.5 Visualize Nodes by Size and Color", " Chapter 3 Visualizing Nodes In this chapter, we continue to use the American Mafia data introduced in Chapter 2. This chapter covers the following topics: How to convert node coordinates into point geometry How to visualize nodes with constant color and size How to visualize nodes with varying node size by attributes How to visualize nodes with varying color by attributes How to visualize nodes with varying node size and color with a combined legend You will be able to find a copy of all the codes at the bottom of the page. Before proceeding to the codes, please load the following packages: library(sf) library(tidyverse) library(tmap) library(igraph) library(RColorBrewer) library(tigris) #install.packages(&quot;devtools&quot;) #to download R package on GitHub #devtools::install_github(&quot;friendlycities-gatech/SSNtools&quot;) library(SSNtools) 3.1 Convert Coordinates to Points The data for the nodes may come in two common format. One is the node table that we mentioned in Chapter 2 (REF), and the other is spatial object, in which nodes are already point geometry. The node table often stores the spatial information of the node as two columns: latitude and longitude. Spatial object contains spatial information of the node in the geometry column. It also includes projection coordinates system of the object. Unless you are working with ggplot2, most other visualization packages require nodes to be spatial objects for mapping. You can convert a node table with coordinates into a spatial object with st_as_sf function in sf package. Spatial information is stored in the LonX and LatY column in MafiaNodes node table. Therefore, when we convert it to sf spatial object, we need to set the coordinates crs to be WGS84 (4326). #MafiaNodes is a built-in dataset in SSNtools R package MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) head(MafiaSpatial, 3) ## Simple feature collection with 3 features and 4 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -117.291 ymin: 34.1493 xmax: -77.5774 ymax: 43.1356 ## CRS: EPSG:4326 ## NODE Family NY NiceLabel ## 1 VALENTI-COSTENZA Bonanno 1 Costenza Valenti ## 2 VALENTI-FRANK Bonanno 1 Frank Valenti ## 3 DIPOLLITO-JOSEPH Los_Angeles 0 Joseph Dipollito ## geometry ## 1 POINT (-77.6064 43.1349) ## 2 POINT (-77.5774 43.1356) ## 3 POINT (-117.291 34.1493) 3.2 Visualize Nodes First step, we download the U.S. state shapefile through tigris package as the background for visualization and transform the shapefile and the dataframe data to the appropriate crs (coordinate reference system). The coordinate information can be stored in other projection system other than the commonly used WGS84. Users need to find out what crs is used before transforming the data to another system. Only when crs are the same for two or more shapefiles (or geometry) can we overlay them correctly on each other. Since we are mapping the data on U.S. mainland, we exclude U.S. territories and further transform the node table into sf spatial objects with North America Equidistant Conic projection (crs=102010). #Convert coordinate system MafiaSpatial = MafiaSpatial %&gt;% st_transform(MafiaSpatioal, crs=102010) #states is a function in tigris to download U.S. state boundary shapefile us_states = states(cb=TRUE, progress_bar = FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) %&gt;% st_transform(crs=102010) Second step: visualize the nodes on the US state map! tmap_mode(&#39;plot&#39;) # set tmap plotting mode to static map tm_shape(us_states) + tm_polygons() + #draw U.S. state shapefile first as polygons tm_shape(MafiaSpatial) + tm_symbols() #overlay nodes as points 3.3 Visualize Nodes by Node Color The map above only shows the locations of Mafia members. We want to visualize the influence of these members and find out where influential people reside. We load the edge file MafiaEdges and calculate the degree of each node. To vary the node color by degree, we simply set the col argument to the variable degree that should vary by color. Different from node size, style argument can modulate the breaks for node color in different styles, such as quantile breaks, equal interval breaks, head/tail breaks and so on. The number of class is defaulted to five. To define the color, you can either pass a R palette (e.g., YlGnBu) or a vector of color to palette argument. More details can be found in tmap document. #MafiaEdges is a built-in dataset in SSNtools #Construct a network and calculate the degree for each node. g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( size=1, #constant node size col=&#39;degree&#39;, palette = &#39;YlGnBu&#39;, #define which numeric column to vary by color and the color palette style=&#39;quantile&#39;, n = 4, #define the color breaks using quantile, and set the number of classes to 4. alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, title.col=c(&#39;Degree of Connections&#39;)) 3.4 Visualize Nodes by Node Size To visualize the node size by the connection degree, we have to set the node size varies by degree in tm_symbols. The default breaks for node size is interval breaks. You can adjust the breaks for node size in the legend directly through sizes.legend argument in tm_symbols. # Visualize tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + #turn the background color of the polygons to transparent tm_shape(MafiaSpatial) + tm_symbols(size=&quot;degree&quot;, scale=2, #scale up the node size col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, title.size=c(&#39;Degree of Connections&#39;)) If you want node size to follow a particular break, then nodes need to be grouped into size brackets. Differnt from color whose breaks can be adjusted in style argument (e.g., style=‘quantile’), changing node size is not straightforward. This example shows how to size nodes in quantile breaks. We first check the quantile breakdown of the degree in the data as the reference. Then, we create a new degree_brackets column that group nodes with different degree to ordered categories. Lastly, we set the size argument in tm_symbols to the new degree_brackets column, which changes the size of the nodes in the map. We adjust the legend breaks using sizes.legend. sizes.legend only changes the size of the nodes in the legend but not for nodes in the map (use scale for the latter). More details can be found in tmap document. The final node size in the map = relative node size defined in degree_brackets / size.max * scale Numbers in the degree_brackets column only define the relative size difference between the nodes. size.max and scale are often defaulted to be 1, therefore makes it easy for people to directly define node size in the degree_brackets column. In that case, the node with designated with the highest size value will have the node size of 1. In our example, node size of 1 is visually too small in the map, so we scale up the node size by 1.5. Thus, the actual node sizes for the four brackets are c(0.1, 0.3, 0.5, 1)/1*1.5 = c(0.15, 0.45, 0.75, 1.5). quantile(MafiaSpatial$degree) ## 0% 25% 50% 75% 100% ## 2 8 12 20 154 # Create a new &#39;degree_bracket&#39; column that contains the node size for each group of nodes. MafiaSpatial = MafiaSpatial %&gt;% mutate(degree_brackets = case_when( degree &gt;= 2 &amp; degree &lt; 8 ~ 0.1, degree &gt;= 8 &amp; degree &lt; 12 ~ 0.3, degree &gt;= 12 &amp; degree &lt; 20 ~ 0.5, degree &gt;= 20 &amp; degree &lt;= 154 ~ 1 )) # Visualize tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, sizes.legend = c(0.1, 0.3, 0.5, 1)/1*1.5, sizes.legend.labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), col=&#39;lightblue&#39;, border.col=&#39;#6698CC&#39;, #blue grey alpha=0.5, border.alpha = 0.5, title.size=c(&#39;Degree of Connections&#39;)) 3.5 Visualize Nodes by Size and Color The automatic legend in tmap now cannot support color and size legend in one. To combine the color and size legend, we have to manually create a legend with the color and size attributes from the color and size legends, using tm_add_legend. To replicate the color, we use RColorBrewer package to generate colors for a given number, which is the default way that tmap assigns colors. To replicate the size, we pass in the square root of the actual node size. Setting node size in tm_add_legend is tricky, which is the square roots of the actual node size (see here for detail explanation). Remember: The final node size in the map = relative node size defined in degree_brackets / size.max * scale. Lastly, we set the legend.col.show =FALSE and legend.size.show =FALSE to hide the default legends. tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( #arguments that define point sizes size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, legend.size.show = FALSE, #arguments that define point colors col=&#39;degree_brackets&#39;, palette = &#39;YlGnBu&#39;, n = 4, alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, legend.col.show = FALSE) + tm_add_legend(type=c(&quot;symbol&quot;), col = brewer.pal(4, &quot;YlGnBu&quot;), #copy the color from R palette alpha = 0.5, is.portrait = FALSE, # legend becomes horizontal # size defined here should be the sqaure root of the normalized point size * scale. # The square root is taken since the area is proportional to the data, not the radius. size = (c(0.1,0.3,0.5,1)/1)^0.5*1.5, labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), #break labels border.col = &#39;black&#39;, border.alpha = 0.2, title = c(&quot;Degree of Connections&quot;)) The full codes for creating the map above is in the following: library(readr) library(igraph) library(tmap) library(sf) library(tidyverse) library(RColorBrewer) library(SSNtools) #read data MafiaSpatial = MafiaNodes %&gt;% st_as_sf(coords=c(&quot;LonX&quot;, &quot;LatY&quot;), crs = 4326) us_states = states(cb=TRUE, progress_bar=FALSE) %&gt;% filter(!STUSPS %in% c(&#39;PR&#39;,&#39;AS&#39;, &#39;AK&#39;, &#39;GU&#39;,&#39;MP&#39;,&#39;VI&#39;, &#39;HI&#39;)) %&gt;% st_transform(crs=102010) # Construct a network and calculate the degree for each node. g = graph_from_data_frame(MafiaEdges, directed = FALSE, vertices=MafiaSpatial) MafiaSpatial$degree = degree(g) # Create a new column that assign point size to points with varying degree. MafiaSpatial = MafiaSpatial %&gt;% mutate(degree_brackets = case_when( degree &gt;= quantile(MafiaSpatial$degree)[1] &amp; degree &lt; quantile(MafiaSpatial$degree)[2] ~ 0.1, degree &gt;= quantile(MafiaSpatial$degree)[2] &amp; degree &lt; quantile(MafiaSpatial$degree)[3] ~ 0.3, degree &gt;= quantile(MafiaSpatial$degree)[3] &amp; degree &lt; quantile(MafiaSpatial$degree)[4] ~ 0.5, degree &gt;= quantile(MafiaSpatial$degree)[4] &amp; degree &lt;= quantile(MafiaSpatial$degree)[5] ~ 1 )) # Visualize tmap_mode(&#39;plot&#39;) tm_shape(us_states) + tm_polygons(alpha=0) + tm_shape(MafiaSpatial) + tm_symbols( #arguments that define point sizes size=&quot;degree_brackets&quot;, size.max = 1, scale = 1.5, legend.size.show = FALSE, #arguments that define point colors col=&#39;degree&#39;, palette = &#39;YlGnBu&#39;, style=&#39;quantile&#39;, n = 4, alpha=0.5, border.col=&#39;black&#39;, border.alpha = 0.5, legend.col.show = FALSE) + tm_add_legend(type=c(&quot;symbol&quot;), col = brewer.pal(4, &quot;YlGnBu&quot;), #copy the color from R palette alpha = 0.5, is.portrait = FALSE, # legend becomes horizontal # size defined here should be the sqaure root of the normalized point size * scale. # The square root is taken since the area is proportional to the data, not the radius. size = (c(0.1,0.3,0.5,1)/1)^0.5*1.5, labels = c(&#39;2-8&#39;,&#39;8-12&#39;,&#39;12-20&#39;,&#39;20-154&#39;), #break labels border.col = &#39;black&#39;, border.alpha = 0.2, title = c(&quot;Degree of Connections&quot;)) "],
["edges.html", "Chapter 4 Visualizing Edges 4.1 Convert Points into Lines 4.2 Visualizing Edges 4.3 Visualizing Edges by Line Width 4.4 Visualizing Edges by Color 4.5 Visualizing Edges by Width and Color", " Chapter 4 Visualizing Edges In this chapter, we will use commute data from U.S. Census LEHD (Longitudinal Employer-Household Dynamics) Origin-Destination Employment Statistics (LODES). We will use lehdr package to download LODES commute data between counties in Georgia and use tigris to download county shapefiles and convert to centroids as points in the spatial networks. This chapter covers the following topics: How to convert point data into line geometry How to visualize edges with constant color and size How to visualize edges with varying edge width by attributes How to visualize edges with varying edge color by attributes How to visualize edges with varying edge size and edge color with a combined legend You will be able to find a copy of all the codes at the bottom of the page. Before proceeding to the codes, please load the following packages: library(sf) library(tidyverse) library(tmap) library(tigris) library(lehdr) 4.1 Convert Points into Lines To start, we use lehdr package to download LODES commute data between counties in Georgia and use tigris package to download county shapefiles and convert to centroids as points in the spatial networks. #counties is a function in tigris package GA_county = counties(state = &#39;GA&#39;, cb=TRUE, year=2018, progress_bar=FALSE) #grab_lodes is a function in lehdr package data = grab_lodes(state=&#39;ga&#39;, year=2018, lodes_type = &#39;od&#39;, state_part = &#39;main&#39;, agg_geo = &#39;county&#39;) #filter top 1000 county-to-county flows ctc_commutes = data %&gt;% select(c(w_county, h_county, S000)) %&gt;% rename(flow = S000) %&gt;% filter(h_county != w_county) %&gt;% arrange(desc(flow)) %&gt;% slice(1:1000) head(ctc_commutes, 3) ## # A tibble: 3 × 3 ## w_county h_county flow ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 13121 13089 128889 ## 2 13121 13067 109627 ## 3 13121 13135 87646 Columns h_county and w_county contain the county FIPS (or GEOID) codes. S000 contains the total number of job flows between the home county and the work county. We also only want to create lines between counties, so we will filter out flows that have the same h_county and w_county. There are two ways to convert points into a line geometry. 4.1.1 Method 1: Group by lineID and Summarize Points into Line The first one is to group the points coordinates by line ID, summarize the flow values, and then use st_cast in the sf package to turn the grouped point coordinates into a line geometry. This method is particularly useful if you start with a file that only contain coordinates but no geometry. It is also convenient GPS trajectory data because each row is a point data associated with a line ID and you want to connect all the points that represent one trajectory. For our data, we have a flow dataframe that contains the origin and destination ID and the flow volumn, and a separate county centroid shapefile that can be joined to the flow dataframe. To leverage method 1, we have to split one OD pair into two rows so that the first row contains the point geometry of the origin and the second row contains the point geometry of the destination. To do that, we perform a little trick: we swap the position of the h_county and w_county of ctc_commutes and bind it to the existing ctc_commutes dataframe. Then when we join county shapefiles by h_county, we actually join the shapefiles for both the origin county and the destination county. Then we can use the group_by and summarise method to create lines. Noted that column ID needs to be created before and during binding the ctc_commutes, so that group_by knows which OD is one the same line. You also need to ensure the dataframe is an sf object after doing left_join through st_as_sf(). edges = ctc_commutes %&gt;% mutate(ID = row_number()) %&gt;% bind_rows(ctc_commutes %&gt;% rename(w_county = h_county, h_county = w_county) %&gt;% mutate(ID = row_number())) %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% st_as_sf() %&gt;% group_by(ID) %&gt;% summarize(w_county=first(w_county), h_county = first(h_county), flow=mean(flow)) %&gt;% st_cast(&quot;LINESTRING&quot;) head(edges, 3) ## Simple feature collection with 3 features and 4 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -84.5767 ymin: 33.77149 xmax: -84.02363 ymax: 33.96167 ## CRS: 4269 ## # A tibble: 3 × 5 ## ID w_county h_county flow geometry ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;LINESTRING [°]&gt; ## 1 1 13121 13089 128889 (-84.4676 33.78992, -84.22637 33.77149) ## 2 2 13121 13067 109627 (-84.5767 33.94143, -84.4676 33.78992) ## 3 3 13121 13135 87646 (-84.4676 33.78992, -84.02363 33.96167) 4.1.2 Method 2: Join Two Point Geometry into One Row and Unite into Line The second way to convert points into lines is to join two point geometry in one row and cast them into a line. This method is particularly useful if you already have separate geometry files for origin and destination nodes, which is the case for our data. edges = ctc_commutes %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;w_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% mutate(geometry = st_cast(st_union(geometry.x, geometry.y), &quot;LINESTRING&quot;)) %&gt;% select(-c(geometry.x, geometry.y)) %&gt;% st_as_sf() head(edges, 3) ## Simple feature collection with 3 features and 3 fields ## Geometry type: LINESTRING ## Dimension: XY ## Bounding box: xmin: -84.5767 ymin: 33.77149 xmax: -84.02363 ymax: 33.96167 ## CRS: 4269 ## # A tibble: 3 × 4 ## w_county h_county flow geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;LINESTRING [°]&gt; ## 1 13121 13089 128889 (-84.4676 33.78992, -84.22637 33.77149) ## 2 13121 13067 109627 (-84.5767 33.94143, -84.4676 33.78992) ## 3 13121 13135 87646 (-84.4676 33.78992, -84.02363 33.96167) 4.2 Visualizing Edges The simplest edge visualization code snippet using tmap is the following: tmap_mode(&#39;plot&#39;) #Visualize edges tm_shape(GA_county) + tm_polygons() + tm_shape(edges) + tm_lines() 4.3 Visualizing Edges by Line Width To visualize edges by line width, we added a column variable flow for line width in tm_lines(). tmap_mode(&#39;plot&#39;) tm_shape(GA_county) + #change polygon background to be transparent tm_polygons(alpha=0, border.col = &#39;black&#39;) + tm_shape(edges) + #define line width and properties associated with lines tm_lines(lwd=&#39;flow&#39;, scale=10, alpha=0.5, legend.lwd.is.portrait = TRUE, title.lwd = c(&#39;Commutes Across Counties&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.07)) The default line width setting is proportional to the column variable (in this case, flow values). As you can see, this default is not a good visualization for the map because edges with small amount of flows are too thin to be seen. In reality, the degree weight distribution of non-planar networks is often skewed, with a few edges have very high flow values and most of the rest have low values. Therefore, we need to adjust the breaks to better visualize the spatial network. To adjust the line width breaks, we need to create a column to store relative edge width, which is similar to the node size visualization in chapter 2. We chose a skewed quantile breaks for line width. # We design the breaks for edge width through a skewed quantile distribution brks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0) # We create a column called flow_breaks that stores relative line width edges = edges %&gt;% mutate( flow_width = case_when( flow &gt;= brks[1] &amp; flow &lt;= brks[2] ~ 0.1, flow &gt; brks[2] &amp; flow &lt;= brks[3] ~ 0.3, flow &gt; brks[3] &amp; flow &lt;= brks[4] ~ 0.5, flow &gt; brks[4] &amp; flow &lt;= brks[5] ~ 1 ) ) tmap_mode(&#39;plot&#39;) tm_shape(GA_county) + tm_polygons(alpha=0, border.col = &#39;black&#39;) + # commute edges are arranged by flow values from high to low so that # high volumn flows will be plotted on the top of the low value ones. tm_shape(arrange(edges, flow)) + tm_lines(lwd=&quot;flow_width&quot;, scale=2, alpha=0.5, lwd.legend = c(0.1, 0.3, 0.5, 1)*2, legend.lwd.is.portrait = TRUE, lwd.legend.labels=c(&#39;300-600&#39;,&#39;601-3400&#39;, &#39;3401-30,000&#39;,&#39;30,001-130,000&#39;), title.lwd = c(&#39;Commutes Across Counties&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.05)) 4.4 Visualizing Edges by Color To visualize edges by color, we assign a variable column flow to argument col in tm_lines. Since we already established that the edges are better viewed through a skewed flow breaks, we manually assign break values for color. To do that, we give argument breaks a vector of fixed numbers, and set argument style to fixed. The following map has constant line width across different colors. tmap_mode(&#39;plot&#39;) tm_shape(GA_county) + tm_polygons(alpha=0, border.col = &#39;black&#39;) + tm_shape(arrange(edges, flow)) + # all the parameters for adjusting colors tm_lines(col=&quot;flow&quot;, alpha=0.5, scale = 1, breaks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, title.col = c(&#39;Commutes Across Counties&#39;), labels=c(&#39;300-600&#39;,&#39;601-3400&#39;,&#39;3401-30,000&#39;,&#39;30,001-130,000&#39;), palette=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;)) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.05)) 4.5 Visualizing Edges by Width and Color Similar to node visualization, to visualize edges with both line width and color, we need to add arguments for both and create a combined legend through tm_add_legend. Unfortunately, the package does not have an automatic way to combine color and line width legend together, so we have to define the values manually. tmap_mode(&#39;plot&#39;) map = tm_shape(GA_county) + tm_polygons(alpha=0, border.col = &#39;black&#39;) + tm_shape(arrange(edges, flow)) + tm_lines( #arguments that define the styles for color col=&quot;flow&quot;, alpha=0.8, breaks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, palette=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;), legend.col.show = FALSE, #arguments that define the styles for line width lwd=&quot;flow_width&quot;, scale=2, legend.lwd.show = FALSE) + #add manual legends to combine color and line width schema tm_add_legend( type=c(&#39;line&#39;), col=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;), lwd=c(1, 0.5, 0.3, 0.1), labels=c(&#39;300-600&#39;,&#39;601-3400&#39;,&#39;3401-30,000&#39;,&#39;30,001-130,000&#39;), title=&#39;Commutes Across Counties&#39;) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.05)) map Perfect! Now we can see clearly that commutes across counties are most intensive around the Atlanta metropolitan area and less so in the south of the state. We can further perfect the map by adding information about within county flows and visualize the numbers as node sizes. Here we show a new technique, which is to save the map we already plotted as a variable, and add new components to it. In this way, we do not have to regenerate the portion of the map that we already produced and speed up the mapping and testing time dramatically! # creating nodes as point geometry that represent within county flows nodes = data %&gt;% select(c(w_county, h_county, S000)) %&gt;% rename(flow = S000) %&gt;% filter(h_county == w_county) %&gt;% left_join(GA_county %&gt;% st_centroid(), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% st_as_sf() # here we use quantile breaks for node size brks = quantile(nodes$flow, probs=seq(0, 1, 0.25)) nodes = nodes %&gt;% mutate( size = case_when( flow &gt;= brks[1] &amp; flow &lt;= brks[2] ~ 0.1, flow &gt; brks[2] &amp; flow &lt;= brks[3] ~ 0.3, flow &gt; brks[3] &amp; flow &lt;= brks[4] ~ 0.5, flow &gt; brks[4] &amp; flow &lt;= brks[5] ~ 1 ) ) #visualize nodes on top of the map from last section map + tm_shape(nodes) + tm_symbols( size=&quot;size&quot;, scale=0.8, alpha=0, border.col=&#39;black&#39;, border.alpha=0.5, # values in sizes.legend = relative size defined in &#39;size&#39; column * scale sizes.legend = c(0.1, 0.3, 0.5, 1)*0.8, # labels have rounded the break values sizes.legend.labels=c(&#39;70-1000&#39;,&#39;1001-2500&#39;,&#39;2501-7000&#39;,&#39;7001-250,000&#39;), title.size=c(&#39;Commutes Within Counties&#39;), legend.size.is.portrait = TRUE) + tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.25)) #added margins to accomodate legends Here is the full code to replicate the map above library(sf) library(tidyverse) library(tmap) library(tigris) library(lehdr) #counties is a function in tigris package GA_county = counties(state = &#39;GA&#39;, cb=TRUE, year=2018, progress_bar=FALSE) #grab_lodes is a function in lehdr package data = grab_lodes(state=&#39;ga&#39;, year=2018, lodes_type = &#39;od&#39;, state_part = &#39;main&#39;, agg_geo = &#39;county&#39;) #filter top 1000 county-to-county flows ctc_commutes = data %&gt;% select(c(w_county, h_county, S000)) %&gt;% rename(flow = S000) %&gt;% filter(h_county != w_county) %&gt;% arrange(desc(flow)) %&gt;% slice(1:1000) #--- Create lines from OD dataframe ---# edges = ctc_commutes %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% left_join(GA_county %&gt;% st_centroid() %&gt;% select(c(GEOID, geometry)), by=c(&#39;w_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% mutate(geometry = st_cast(st_union(geometry.x, geometry.y), &quot;LINESTRING&quot;)) %&gt;% select(-c(geometry.x, geometry.y)) %&gt;% st_as_sf() # --- Convert flows within county into point geometry --- # nodes = data %&gt;% select(c(w_county, h_county, S000)) %&gt;% rename(flow = S000) %&gt;% filter(h_county == w_county) %&gt;% left_join(GA_county %&gt;% st_centroid(), by=c(&#39;h_county&#39; = &#39;GEOID&#39;), copy=FALSE) %&gt;% st_as_sf() # --- Create Breaks for edge width --- # brks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0) edges = edges %&gt;% mutate( flow_width = case_when( flow &gt;= brks[1] &amp; flow &lt;= brks[2] ~ 0.1, flow &gt; brks[2] &amp; flow &lt;= brks[3] ~ 0.3, flow &gt; brks[3] &amp; flow &lt;= brks[4] ~ 0.5, flow &gt; brks[4] &amp; flow &lt;= brks[5] ~ 1 ) ) # --- Create Breaks for node size --- # brks2 = quantile(nodes$flow, probs=seq(0, 1, 0.25)) nodes = nodes %&gt;% mutate( size = case_when( flow &gt;= brks2[1] &amp; flow &lt;= brks2[2] ~ 0.1, flow &gt; brks2[2] &amp; flow &lt;= brks2[3] ~ 0.3, flow &gt; brks2[3] &amp; flow &lt;= brks2[4] ~ 0.5, flow &gt; brks2[4] &amp; flow &lt;= brks2[5] ~ 1 ) ) # --- Visualize the map ---- # tmap_mode(&#39;plot&#39;) map = tm_shape(GA_county) + tm_polygons(alpha=0, border.col = &#39;black&#39;) + tm_shape(arrange(edges, flow)) + tm_lines( #arguments that define the styles for color col=&quot;flow&quot;, alpha=0.8, breaks = round(quantile(edges$flow, probs=c(0, 0.5, 0.9, 0.99, 1)), 0), style=&quot;fixed&quot;, n = 4, palette=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;), legend.col.show = FALSE, #arguments that define the styles for line width lwd=&quot;flow_width&quot;, scale=2, legend.lwd.show = FALSE) + #add manual legends to combine color and line width schema tm_add_legend( type=c(&#39;line&#39;), col=c(&#39;#094081&#39;, &#39;#2B8CBE&#39;, &#39;#7BCCC4&#39;, &#39;#CCEBC5&#39;), lwd=c(1, 0.5, 0.3, 0.1), labels=c(&#39;300-600&#39;,&#39;601-3400&#39;,&#39;3401-30,000&#39;,&#39;30,001-130,000&#39;), title=&#39;Commutes Across Counties&#39;) + #add inner margin to accomodate legend size tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.1)) + # visualize nodes tm_shape(nodes) + tm_symbols( size=&quot;size&quot;, scale=0.8, alpha=0, border.col=&#39;black&#39;, border.alpha=0.5, # values in sizes.legend = relative size defined in &#39;size&#39; column * scale sizes.legend = c(0.1, 0.3, 0.5, 1)*0.8, # labels have rounded the break values sizes.legend.labels=c(&#39;70-1000&#39;,&#39;1001-2500&#39;,&#39;2501-7000&#39;,&#39;7001-250,000&#39;), title.size=c(&#39;Commutes Within Counties&#39;), legend.size.is.portrait = TRUE) + # since the default layout is too small to accomodate both legends tm_layout(legend.position = c(&#39;right&#39;, &#39;top&#39;), inner.margins = c(0.02, 0.02, 0.02, 0.25)) map "],
["final-words.html", "Chapter 5 Final Words", " Chapter 5 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
